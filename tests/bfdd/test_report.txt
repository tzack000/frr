======================================================================
MICRO-BFD (RFC 7130) UNIT TEST REPORT
======================================================================

SUMMARY
----------------------------------------------------------------------
  Total Tests:  47
  Passed:       44
  Failed:       3
  Errors:       0
  Skipped:      0

  Pass Rate:    93.6%

TEST CATEGORIES
----------------------------------------------------------------------
  Constants & Definitions
  Data Structures
  Function Declarations
  Implementation
  YANG Model
  CLI Commands
  Northbound Callbacks
  Zebra Integration
  Documentation
  Build System
  Topotest Framework

FAILURES
----------------------------------------------------------------------
  FAIL: test_lag_command_defined (__main__.TestMicroBFDCLI)
        File "/home/ubuntu/sonic/frr/tests/bfdd/test_bfd_lag.py", line 303, in test_lag_command_defined
        self.assertIn('"lag IFNAME', self.cli_content,
        AssertionError: '"lag IFNAME' not found in '// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * BFD daemon CLI implementation.\n *\n * Copyright (C) 2019 Network Device Education Foundation, Inc. ("NetDEF")\n *                    Rafael Zalamena\n */\n\n#include <zebra.h>\n\n#include "lib/command.h"\n#include "lib/log.h"\n#include "lib/northbound_cli.h"\n#include "lib/termtable.h"\n#include "lib/ipaddr.h"\n\n#ifndef VTYSH_EXTRACT_PL\n#include "bfdd/bfdd_cli_clippy.c"\n#endif /* VTYSH_EXTRACT_PL */\n\n#include "bfd.h"\n#include "bfdd_nb.h"\n\n/*\n * Definitions.\n */\n#define PEER_STR "Configure peer\\n"\n#define INTERFACE_NAME_STR "Configure interface name to use\\n"\n#define PEER_IPV4_STR "IPv4 peer address\\n"\n#define PEER_IPV6_STR "IPv6 peer address\\n"\n#define MHOP_STR "Configure multihop\\n"\n#define LOCAL_STR "Configure local address\\n"\n#define LOCAL_IPV4_STR "IPv4 local address\\n"\n#define LOCAL_IPV6_STR "IPv6 local address\\n"\n#define LOCAL_INTF_STR "Configure local interface name to use\\n"\n#define VRF_STR "Configure VRF\\n"\n#define VRF_NAME_STR "Configure VRF name\\n"\n#define SESSION_NAME_STR       "Specify bfd session name\\n"\n#define SET_SESSION_NAME_STR   "bfd session name\\n"\n#define SESSION_MODE_STR       "Specify bfd session mode\\n"\n#define APPLY_SESSION_MODE_STR "Enable bfd mode\\n"\n\n/*\n * Prototypes.\n */\nstatic bool\nbfd_cli_is_single_hop(struct vty *vty)\n{\n\treturn strstr(VTY_CURR_XPATH, "/single-hop") != NULL;\n}\n\nstatic bool bfd_cli_is_sbfd_echo(struct vty *vty)\n{\n\treturn strstr(VTY_CURR_XPATH, "/sbfd-echo") != NULL;\n}\n\n\nstatic bool\nbfd_cli_is_profile(struct vty *vty)\n{\n\treturn strstr(VTY_CURR_XPATH, "/bfd/profile") != NULL;\n}\n\n/*\n * Functions.\n */\nDEFPY_YANG_NOSH(\n\tbfd_enter, bfd_enter_cmd,\n\t"bfd",\n\t"Configure BFD peers\\n")\n{\n\tint ret;\n\n\tnb_cli_enqueue_change(vty, "/frr-bfdd:bfdd/bfd", NB_OP_CREATE, NULL);\n\tret = nb_cli_apply_changes(vty, NULL);\n\tif (ret == CMD_SUCCESS)\n\t\tVTY_PUSH_XPATH(BFD_NODE, "/frr-bfdd:bfdd/bfd");\n\n\treturn ret;\n}\n\nDEFUN_YANG(\n\tbfd_config_reset, bfd_config_reset_cmd,\n\t"no bfd",\n\tNO_STR\n\t"Configure BFD peers\\n")\n{\n\tnb_cli_enqueue_change(vty, "/frr-bfdd:bfdd/bfd", NB_OP_DESTROY, NULL);\n\treturn nb_cli_apply_changes(vty, NULL);\n}\n\nvoid bfd_cli_show_header(struct vty *vty,\n\t\t\t const struct lyd_node *dnode\n\t\t\t __attribute__((__unused__)),\n\t\t\t bool show_defaults __attribute__((__unused__)))\n{\n\tvty_out(vty, "!\\nbfd\\n");\n}\n\nvoid bfd_cli_show_header_end(struct vty *vty, const struct lyd_node *dnode\n\t\t\t     __attribute__((__unused__)))\n{\n\tvty_out(vty, "exit\\n");\n\tvty_out(vty, "!\\n");\n}\n\nDEFPY_YANG_NOSH(\n\tbfd_peer_enter, bfd_peer_enter_cmd,\n\t"peer <A.B.C.D|X:X::X:X> [{multihop$multihop|local-address <A.B.C.D|X:X::X:X>|interface IFNAME$ifname|vrf NAME}]",\n\tPEER_STR\n\tPEER_IPV4_STR\n\tPEER_IPV6_STR\n\tMHOP_STR\n\tLOCAL_STR\n\tLOCAL_IPV4_STR\n\tLOCAL_IPV6_STR\n\tINTERFACE_STR\n\tLOCAL_INTF_STR\n\tVRF_STR\n\tVRF_NAME_STR)\n{\n\tint ret, slen;\n\tchar source_str[INET6_ADDRSTRLEN + 32];\n\tchar xpath[XPATH_MAXLEN], xpath_srcaddr[XPATH_MAXLEN + 32];\n\n\tif (multihop) {\n\t\tif (!local_address_str) {\n\t\t\tvty_out(vty,\n\t\t\t\t"%% local-address is required when using multihop\\n");\n\t\t\treturn CMD_WARNING_CONFIG_FAILED;\n\t\t}\n\t\tif (ifname) {\n\t\t\tvty_out(vty,\n\t\t\t\t"%% interface is prohibited when using multihop\\n");\n\t\t\treturn CMD_WARNING_CONFIG_FAILED;\n\t\t}\n\t\tsnprintf(source_str, sizeof(source_str), "[source-addr=\'%s\']",\n\t\t\t local_address_str);\n\t} else\n\t\tsource_str[0] = 0;\n\n\tslen = snprintf(xpath, sizeof(xpath),\n\t\t\t"/frr-bfdd:bfdd/bfd/sessions/%s%s[dest-addr=\'%s\']",\n\t\t\tmultihop ? "multi-hop" : "single-hop", source_str,\n\t\t\tpeer_str);\n\tif (ifname)\n\t\tslen += snprintf(xpath + slen, sizeof(xpath) - slen,\n\t\t\t\t "[interface=\'%s\']", ifname);\n\telse if (!multihop)\n\t\tslen += snprintf(xpath + slen, sizeof(xpath) - slen,\n\t\t\t\t "[interface=\'*\']");\n\tif (vrf)\n\t\tsnprintf(xpath + slen, sizeof(xpath) - slen, "[vrf=\'%s\']", vrf);\n\telse\n\t\tsnprintf(xpath + slen, sizeof(xpath) - slen, "[vrf=\'%s\']",\n\t\t\t VRF_DEFAULT_NAME);\n\n\tnb_cli_enqueue_change(vty, xpath, NB_OP_CREATE, NULL);\n\tif (multihop == NULL && local_address_str != NULL) {\n\t\tsnprintf(xpath_srcaddr, sizeof(xpath_srcaddr),\n\t\t\t "%s/source-addr", xpath);\n\t\tnb_cli_enqueue_change(vty, xpath_srcaddr, NB_OP_MODIFY,\n\t\t\t\t      local_address_str);\n\t}\n\n\t/* Apply settings immediately. */\n\tret = nb_cli_apply_changes(vty, NULL);\n\tif (ret == CMD_SUCCESS)\n\t\tVTY_PUSH_XPATH(BFD_PEER_NODE, xpath);\n\n\treturn ret;\n}\n\nDEFPY_YANG(\n\tbfd_no_peer, bfd_no_peer_cmd,\n\t"no peer <A.B.C.D|X:X::X:X> [{multihop$multihop|local-address <A.B.C.D|X:X::X:X>|interface IFNAME$ifname|vrf NAME}]",\n\tNO_STR\n\tPEER_STR\n\tPEER_IPV4_STR\n\tPEER_IPV6_STR\n\tMHOP_STR\n\tLOCAL_STR\n\tLOCAL_IPV4_STR\n\tLOCAL_IPV6_STR\n\tINTERFACE_STR\n\tLOCAL_INTF_STR\n\tVRF_STR\n\tVRF_NAME_STR)\n{\n\tint slen;\n\tchar xpath[XPATH_MAXLEN];\n\tchar source_str[INET6_ADDRSTRLEN + 32];\n\n\tif (multihop) {\n\t\tif (!local_address_str) {\n\t\t\tvty_out(vty,\n\t\t\t\t"%% local-address is required when using multihop\\n");\n\t\t\treturn CMD_WARNING_CONFIG_FAILED;\n\t\t}\n\t\tif (ifname) {\n\t\t\tvty_out(vty,\n\t\t\t\t"%% interface is prohibited when using multihop\\n");\n\t\t\treturn CMD_WARNING_CONFIG_FAILED;\n\t\t}\n\t\tsnprintf(source_str, sizeof(source_str), "[source-addr=\'%s\']",\n\t\t\t local_address_str);\n\t} else\n\t\tsource_str[0] = 0;\n\n\tslen = snprintf(xpath, sizeof(xpath),\n\t\t\t"/frr-bfdd:bfdd/bfd/sessions/%s%s[dest-addr=\'%s\']",\n\t\t\tmultihop ? "multi-hop" : "single-hop", source_str,\n\t\t\tpeer_str);\n\tif (ifname)\n\t\tslen += snprintf(xpath + slen, sizeof(xpath) - slen,\n\t\t\t\t "[interface=\'%s\']", ifname);\n\telse if (!multihop)\n\t\tslen += snprintf(xpath + slen, sizeof(xpath) - slen,\n\t\t\t\t "[interface=\'*\']");\n\tif (vrf)\n\t\tsnprintf(xpath + slen, sizeof(xpath) - slen, "[vrf=\'%s\']", vrf);\n\telse\n\t\tsnprintf(xpath + slen, sizeof(xpath) - slen, "[vrf=\'%s\']",\n\t\t\t VRF_DEFAULT_NAME);\n\n\tnb_cli_enqueue_change(vty, xpath, NB_OP_DESTROY, NULL);\n\n\t/* Apply settings immediatly. */\n\treturn nb_cli_apply_changes(vty, NULL);\n}\n\nDEFPY_YANG_NOSH(\n\tsbfd_echo_peer_enter, sbfd_echo_peer_enter_cmd,\n\t"peer <A.B.C.D|X:X::X:X> bfd-mode sbfd-echo bfd-name BFDNAME$bfdname \\\n\t[multihop$multihop] local-address <A.B.C.D|X:X::X:X> [vrf NAME] \\\n\tsrv6-source-ipv6 X:X::X:X srv6-encap-data X:X::X:X...",\n\tPEER_STR\n\tPEER_IPV4_STR\n\tPEER_IPV6_STR\n\tSESSION_MODE_STR\n\t"Enable sbfd-echo mode\\n"\n\tSESSION_NAME_STR\n\tSET_SESSION_NAME_STR\n\tMHOP_STR\n\tLOCAL_STR\n\tLOCAL_IPV4_STR\n\tLOCAL_IPV6_STR\n\tVRF_STR\n\tVRF_NAME_STR\n\t"Configure source ipv6 address for srv6 encap\\n"\n\tLOCAL_IPV6_STR\n\t"Configure sidlist data for srv6 encap\\n"\n\t"X:X::X:X IPv6 sid address\\n")\n{\n\tint ret, slen, data_idx = 11;\n\tchar xpath[XPATH_MAXLEN], xpath_sl[XPATH_MAXLEN + 32], xpath_mh[XPATH_MAXLEN + 32];\n\n\tif (!bfdname) {\n\t\tvty_out(vty, "%% ERROR: bfd name is required\\n");\n\t\treturn CMD_WARNING_CONFIG_FAILED;\n\t}\n\n\tif (strcmp(peer_str, local_address_str)) {\n\t\tvty_out(vty,\n\t\t\t"%% ERROR: peer and local-address must be the same in sbfd-echo mode\\n");\n\t\treturn CMD_WARNING_CONFIG_FAILED;\n\t}\n\n\tslen = snprintf(xpath, sizeof(xpath),\n\t\t\t"/frr-bfdd:bfdd/bfd/sessions/sbfd-echo[source-addr=\'%s\'][bfd-name=\'%s\']",\n\t\t\tlocal_address_str, bfdname);\n\n\tif (vrf) {\n\t\tsnprintf(xpath + slen, sizeof(xpath) - slen, "[vrf=\'%s\']", vrf);\n\t\tdata_idx += 2;\n\t} else\n\t\tsnprintf(xpath + slen, sizeof(xpath) - slen, "[vrf=\'%s\']", VRF_DEFAULT_NAME);\n\n\tnb_cli_enqueue_change(vty, xpath, NB_OP_CREATE, NULL);\n\n\tif (multihop) {\n\t\tsnprintf(xpath_mh, sizeof(xpath_mh), "%s/multi-hop", xpath);\n\t\tnb_cli_enqueue_change(vty, xpath_mh, NB_OP_MODIFY, "true");\n\t\tdata_idx += 1;\n\t}\n\n\tfor (int i = data_idx; i < argc; i++) {\n\t\tsnprintf(xpath_sl, sizeof(xpath_sl), "%s/srv6-encap-data", xpath);\n\t\tnb_cli_enqueue_change(vty, xpath_sl, NB_OP_CREATE, argv[i]->arg);\n\t}\n\n\tsnprintf(xpath_sl, sizeof(xpath_sl), "%s/srv6-source-ipv6", xpath);\n\tnb_cli_enqueue_change(vty, xpath_sl, NB_OP_MODIFY, srv6_source_ipv6_str);\n\n\tsnprintf(xpath_sl, sizeof(xpath_sl), "%s/dest-addr", xpath);\n\tnb_cli_enqueue_change(vty, xpath_sl, NB_OP_MODIFY, peer_str);\n\n\t/* Apply settings immediately. */\n\tret = nb_cli_apply_changes(vty, NULL);\n\tif (ret == CMD_SUCCESS)\n\t\tVTY_PUSH_XPATH(BFD_PEER_NODE, xpath);\n\n\treturn ret;\n}\n\nDEFPY_YANG(\n\tsbfd_echo_no_peer, sbfd_echo_no_peer_cmd,\n\t"no peer <A.B.C.D|X:X::X:X> bfd-mode sbfd-echo bfd-name BFDNAME$bfdname \\\n\t[multihop$multihop] local-address <A.B.C.D|X:X::X:X> [vrf NAME] \\\n\tsrv6-source-ipv6 X:X::X:X srv6-encap-data X:X::X:X...",\n\tNO_STR\n\tPEER_STR\n\tPEER_IPV4_STR\n\tPEER_IPV6_STR\n\tSESSION_MODE_STR\n\t"Enable sbfd-echo mode\\n"\n\tSESSION_NAME_STR\n\tSET_SESSION_NAME_STR\n\tMHOP_STR\n\tLOCAL_STR\n\tLOCAL_IPV4_STR\n\tLOCAL_IPV6_STR\n\tVRF_STR\n\tVRF_NAME_STR\n\t"Configure source ipv6 address for srv6 encap\\n"\n\tLOCAL_IPV6_STR\n\t"Configure sidlist data for srv6 encap\\n"\n\t"X:X::X:X IPv6 sid address\\n")\n{\n\tint slen;\n\tchar xpath[XPATH_MAXLEN];\n\n\tslen = snprintf(xpath, sizeof(xpath),\n\t\t\t"/frr-bfdd:bfdd/bfd/sessions/sbfd-echo[source-addr=\'%s\'][bfd-name=\'%s\']",\n\t\t\tlocal_address_str, bfdname);\n\n\tif (vrf)\n\t\tsnprintf(xpath + slen, sizeof(xpath) - slen, "[vrf=\'%s\']", vrf);\n\telse\n\t\tsnprintf(xpath + slen, sizeof(xpath) - slen, "[vrf=\'%s\']", VRF_DEFAULT_NAME);\n\n\tnb_cli_enqueue_change(vty, xpath, NB_OP_DESTROY, NULL);\n\n\t/* Apply settings immediatly. */\n\treturn nb_cli_apply_changes(vty, NULL);\n}\n\n\nDEFPY_YANG_NOSH(\n\tsbfd_init_peer_enter, sbfd_init_peer_enter_cmd,\n\t"peer <A.B.C.D|X:X::X:X> bfd-mode sbfd-init bfd-name BFDNAME$bfdname \\\n\t[multihop$multihop] local-address <A.B.C.D|X:X::X:X> [vrf NAME] \\\n\tremote-discr (1-4294967295)$discr srv6-source-ipv6 X:X::X:X srv6-encap-data X:X::X:X...",\n\tPEER_STR\n\tPEER_IPV4_STR\n\tPEER_IPV6_STR\n\tSESSION_MODE_STR\n\t"Enable sbfd-init mode\\n"\n\tSESSION_NAME_STR\n\tSET_SESSION_NAME_STR\n\tMHOP_STR\n\tLOCAL_STR\n\tLOCAL_IPV4_STR\n\tLOCAL_IPV6_STR\n\tVRF_STR\n\tVRF_NAME_STR\n\t"Configure bfd session remote discriminator\\n"\n\t"Configure remote discriminator\\n"\n\t"Configure source ipv6 address for srv6 encap\\n"\n\tLOCAL_IPV6_STR\n\t"Configure sidlist data for srv6 encap\\n"\n\t"X:X::X:X IPv6 sid address\\n")\n{\n\tint ret, slen, data_idx = 13;\n\tchar xpath[XPATH_MAXLEN], xpath_sl[XPATH_MAXLEN + 32], xpath_rd[XPATH_MAXLEN + 32],\n\t\txpath_mh[XPATH_MAXLEN + 32];\n\tstruct ipaddr peer_addr = { 0 };\n\tstruct ipaddr local_addr = { 0 };\n\n\tif (!bfdname) {\n\t\tvty_out(vty, "%% ERROR: bfd name is required\\n");\n\t\treturn CMD_WARNING_CONFIG_FAILED;\n\t}\n\n\tstr2ipaddr(peer_str, &peer_addr);\n\tif (peer_addr.ipa_type == AF_UNSPEC) {\n\t\tvty_out(vty, "%% ERROR: peer is invalid address\\n");\n\t\treturn CMD_WARNING_CONFIG_FAILED;\n\t}\n\n\tstr2ipaddr(local_address_str, &local_addr);\n\tif (local_addr.ipa_type == AF_UNSPEC) {\n\t\tvty_out(vty, "%% ERROR: local_address is invalid address\\n");\n\t\treturn CMD_WARNING_CONFIG_FAILED;\n\t}\n\n\tif (peer_addr.ipa_type != local_addr.ipa_type) {\n\t\tvty_out(vty, "%% ERROR: peer and local_address are not the same ip version\\n");\n\t\treturn CMD_WARNING_CONFIG_FAILED;\n\t}\n\n\tslen = snprintf(xpath, sizeof(xpath),\n\t\t\t"/frr-bfdd:bfdd/bfd/sessions/sbfd-init[source-addr=\'%s\'][dest-addr=\'%s\'][bfd-name=\'%s\']",\n\t\t\tlocal_address_str, peer_str, bfdname);\n\n\tif (vrf) {\n\t\tsnprintf(xpath + slen, sizeof(xpath) - slen, "[vrf=\'%s\']", vrf);\n\t\tdata_idx += 2;\n\t} else\n\t\tsnprintf(xpath + slen, sizeof(xpath) - slen, "[vrf=\'%s\']", VRF_DEFAULT_NAME);\n\n\tnb_cli_enqueue_change(vty, xpath, NB_OP_CREATE, NULL);\n\n\tif (multihop) {\n\t\tsnprintf(xpath_mh, sizeof(xpath_mh), "%s/multi-hop", xpath);\n\t\tnb_cli_enqueue_change(vty, xpath_mh, NB_OP_MODIFY, "true");\n\t\tdata_idx += 1;\n\t}\n\n\tif (srv6_source_ipv6_str) {\n\t\tfor (int i = data_idx; i < argc; i++) {\n\t\t\tsnprintf(xpath_sl, sizeof(xpath_sl), "%s/srv6-encap-data", xpath);\n\t\t\tnb_cli_enqueue_change(vty, xpath_sl, NB_OP_CREATE, argv[i]->arg);\n\t\t}\n\n\t\tsnprintf(xpath_sl, sizeof(xpath_sl), "%s/srv6-source-ipv6", xpath);\n\t\tnb_cli_enqueue_change(vty, xpath_sl, NB_OP_MODIFY, srv6_source_ipv6_str);\n\t}\n\n\tsnprintf(xpath_rd, sizeof(xpath_rd), "%s/remote-discr", xpath);\n\tnb_cli_enqueue_change(vty, xpath_rd, NB_OP_MODIFY, discr_str);\n\n\t/* Apply settings immediately. */\n\tret = nb_cli_apply_changes(vty, NULL);\n\tif (ret == CMD_SUCCESS)\n\t\tVTY_PUSH_XPATH(BFD_PEER_NODE, xpath);\n\n\treturn ret;\n}\n\nDEFPY_YANG(\n\tsbfd_init_no_peer, sbfd_init_no_peer_cmd,\n\t"no peer <A.B.C.D|X:X::X:X> bfd-mode sbfd-init bfd-name BFDNAME$bfdname \\\n\t[multihop$multihop] local-address <A.B.C.D|X:X::X:X> [vrf NAME] \\\n\tremote-discr (0-4294967295)$discr srv6-source-ipv6 X:X::X:X srv6-encap-data X:X::X:X...",\n\tNO_STR\n\tPEER_STR\n\tPEER_IPV4_STR\n\tPEER_IPV6_STR\n\tSESSION_MODE_STR\n\t"Enable sbfd-init mode\\n"\n\tSESSION_NAME_STR\n\tSET_SESSION_NAME_STR\n\tMHOP_STR\n\tLOCAL_STR\n\tLOCAL_IPV4_STR\n\tLOCAL_IPV6_STR\n\tVRF_STR\n\tVRF_NAME_STR\n\t"Configure bfd session remote discriminator\\n"\n\t"Configure remote discriminator\\n"\n\t"Configure source ipv6 address for srv6 encap\\n"\n\tLOCAL_IPV6_STR\n\t"Configure sidlist data for srv6 encap\\n"\n\t"X:X::X:X IPv6 sid address\\n")\n{\n\tint slen;\n\tchar xpath[XPATH_MAXLEN];\n\n\tslen = snprintf(xpath, sizeof(xpath),\n\t\t\t"/frr-bfdd:bfdd/bfd/sessions/sbfd-init[source-addr=\'%s\'][dest-addr=\'%s\'][bfd-name=\'%s\']",\n\t\t\tlocal_address_str, peer_str, bfdname);\n\n\tif (vrf)\n\t\tsnprintf(xpath + slen, sizeof(xpath) - slen, "[vrf=\'%s\']", vrf);\n\telse\n\t\tsnprintf(xpath + slen, sizeof(xpath) - slen, "[vrf=\'%s\']", VRF_DEFAULT_NAME);\n\n\tnb_cli_enqueue_change(vty, xpath, NB_OP_DESTROY, NULL);\n\n\t/* Apply settings immediatly. */\n\treturn nb_cli_apply_changes(vty, NULL);\n}\n\nDEFPY_YANG_NOSH(\n\tsbfd_init_peer_raw_enter, sbfd_init_peer_raw_enter_cmd,\n\t"peer <A.B.C.D|X:X::X:X> bfd-mode sbfd-init bfd-name BFDNAME$bfdname \\\n\t[multihop$multihop] local-address <A.B.C.D|X:X::X:X> [vrf NAME] \\\n\tremote-discr (1-4294967295)$discr",\n\tPEER_STR\n\tPEER_IPV4_STR\n\tPEER_IPV6_STR\n\tSESSION_MODE_STR\n\t"Enable sbfd-init mode\\n"\n\tSESSION_NAME_STR\n\tSET_SESSION_NAME_STR\n\tMHOP_STR\n\tLOCAL_STR\n\tLOCAL_IPV4_STR\n\tLOCAL_IPV6_STR\n\tVRF_STR\n\tVRF_NAME_STR\n\t"Configure bfd session remote discriminator\\n"\n\t"Configure remote discriminator\\n")\n{\n\tint ret, slen;\n\tchar xpath[XPATH_MAXLEN], xpath_rd[XPATH_MAXLEN + 32], xpath_mh[XPATH_MAXLEN + 32];\n\tstruct ipaddr peer_addr = { 0 };\n\tstruct ipaddr local_addr = { 0 };\n\n\tif (!bfdname) {\n\t\tvty_out(vty, "%% ERROR: bfd name is required\\n");\n\t\treturn CMD_WARNING_CONFIG_FAILED;\n\t}\n\n\tstr2ipaddr(peer_str, &peer_addr);\n\tif (peer_addr.ipa_type == AF_UNSPEC) {\n\t\tvty_out(vty, "%% ERROR: peer is invalid address\\n");\n\t\treturn CMD_WARNING_CONFIG_FAILED;\n\t}\n\n\tstr2ipaddr(local_address_str, &local_addr);\n\tif (local_addr.ipa_type == AF_UNSPEC) {\n\t\tvty_out(vty, "%% ERROR: local_address is invalid address\\n");\n\t\treturn CMD_WARNING_CONFIG_FAILED;\n\t}\n\n\tif (peer_addr.ipa_type != local_addr.ipa_type) {\n\t\tvty_out(vty, "%% ERROR: peer and local_address are not the same ip version\\n");\n\t\treturn CMD_WARNING_CONFIG_FAILED;\n\t}\n\n\tslen = snprintf(xpath, sizeof(xpath),\n\t\t\t"/frr-bfdd:bfdd/bfd/sessions/sbfd-init[source-addr=\'%s\'][dest-addr=\'%s\'][bfd-name=\'%s\']",\n\t\t\tlocal_address_str, peer_str, bfdname);\n\n\tif (vrf)\n\t\tsnprintf(xpath + slen, sizeof(xpath) - slen, "[vrf=\'%s\']", vrf);\n\telse\n\t\tsnprintf(xpath + slen, sizeof(xpath) - slen, "[vrf=\'%s\']", VRF_DEFAULT_NAME);\n\n\tnb_cli_enqueue_change(vty, xpath, NB_OP_CREATE, NULL);\n\n\tif (multihop) {\n\t\tsnprintf(xpath_mh, sizeof(xpath_mh), "%s/multi-hop", xpath);\n\t\tnb_cli_enqueue_change(vty, xpath_mh, NB_OP_MODIFY, "true");\n\t}\n\n\tsnprintf(xpath_rd, sizeof(xpath_rd), "%s/remote-discr", xpath);\n\tnb_cli_enqueue_change(vty, xpath_rd, NB_OP_MODIFY, discr_str);\n\n\t/* Apply settings immediately. */\n\tret = nb_cli_apply_changes(vty, NULL);\n\tif (ret == CMD_SUCCESS)\n\t\tVTY_PUSH_XPATH(BFD_PEER_NODE, xpath);\n\n\treturn ret;\n}\n\nDEFPY_YANG(\n\tsbfd_init_no_peer_raw, sbfd_init_no_peer_raw_cmd,\n\t"no peer <A.B.C.D|X:X::X:X> bfd-mode sbfd-init bfd-name BFDNAME$bfdname \\\n\t[multihop$multihop] local-address <A.B.C.D|X:X::X:X> [vrf NAME] \\\n\tremote-discr (0-4294967295)$discr",\n\tNO_STR\n\tPEER_STR\n\tPEER_IPV4_STR\n\tPEER_IPV6_STR\n\tSESSION_MODE_STR\n\t"Enable sbfd-init mode\\n"\n\tSESSION_NAME_STR\n\tSET_SESSION_NAME_STR\n\tMHOP_STR\n\tLOCAL_STR\n\tLOCAL_IPV4_STR\n\tLOCAL_IPV6_STR\n\tVRF_STR\n\tVRF_NAME_STR\n\t"Configure bfd session remote discriminator\\n"\n\t"Configure remote discriminator\\n")\n{\n\tint slen;\n\tchar xpath[XPATH_MAXLEN];\n\n\tslen = snprintf(xpath, sizeof(xpath),\n\t\t\t"/frr-bfdd:bfdd/bfd/sessions/sbfd-init[source-addr=\'%s\'][dest-addr=\'%s\'][bfd-name=\'%s\']",\n\t\t\tlocal_address_str, peer_str, bfdname);\n\n\tif (vrf)\n\t\tsnprintf(xpath + slen, sizeof(xpath) - slen, "[vrf=\'%s\']", vrf);\n\telse\n\t\tsnprintf(xpath + slen, sizeof(xpath) - slen, "[vrf=\'%s\']", VRF_DEFAULT_NAME);\n\n\tnb_cli_enqueue_change(vty, xpath, NB_OP_DESTROY, NULL);\n\n\t/* Apply settings immediatly. */\n\treturn nb_cli_apply_changes(vty, NULL);\n}\n\nstatic const char *_bfd_cli_bfd_mode_type_to_string(enum bfd_mode_type mode)\n{\n\tswitch (mode) {\n\tcase BFD_MODE_TYPE_BFD:\n\t\treturn "bfd";\n\tcase BFD_MODE_TYPE_SBFD_ECHO:\n\t\treturn "sbfd-echo";\n\tcase BFD_MODE_TYPE_SBFD_INIT:\n\t\treturn "sbfd-init";\n\tdefault:\n\t\treturn "Unknown";\n\t}\n}\n\nstruct sidlist_show_iter {\n\tchar buf[INET6_ADDRSTRLEN * SRV6_MAX_SEGS];\n};\n\nstatic int sidlist_show_iter_cb(const struct lyd_node *dnode, void *arg)\n{\n\tstruct sidlist_show_iter *iter = arg;\n\tconst char *addr;\n\n\taddr = yang_dnode_get_string(dnode, NULL);\n\n\tstrlcat(iter->buf, addr, INET6_ADDRSTRLEN * SRV6_MAX_SEGS);\n\tstrlcat(iter->buf, " ", INET6_ADDRSTRLEN * SRV6_MAX_SEGS);\n\n\treturn YANG_ITER_CONTINUE;\n}\n\nstatic void _bfd_cli_show_peer(struct vty *vty, const struct lyd_node *dnode,\n\t\t\t       bool show_defaults __attribute__((__unused__)), bool mhop,\n\t\t\t       uint32_t bfd_mode)\n{\n\tconst char *vrf = yang_dnode_get_string(dnode, "vrf");\n\tstruct sidlist_show_iter iter = { 0 };\n\n\tvty_out(vty, " peer %s", yang_dnode_get_string(dnode, "./dest-addr"));\n\tif (bfd_mode == BFD_MODE_TYPE_BFD) {\n\t\tif (mhop)\n\t\t\tvty_out(vty, " multihop");\n\n\t\tif (yang_dnode_exists(dnode, "./source-addr"))\n\t\t\tvty_out(vty, " local-address %s",\n\t\t\t\tyang_dnode_get_string(dnode, "./source-addr"));\n\n\t\tif (strcmp(vrf, VRF_DEFAULT_NAME))\n\t\t\tvty_out(vty, " vrf %s", vrf);\n\n\t\tif (!mhop) {\n\t\t\tconst char *ifname = yang_dnode_get_string(dnode, "./interface");\n\n\t\t\tif (strcmp(ifname, "*"))\n\t\t\t\tvty_out(vty, " interface %s", ifname);\n\t\t}\n\t\tvty_out(vty, "\\n");\n\t} else if (bfd_mode == BFD_MODE_TYPE_SBFD_ECHO || bfd_mode == BFD_MODE_TYPE_SBFD_INIT) {\n\t\tvty_out(vty, " bfd-mode %s", _bfd_cli_bfd_mode_type_to_string(bfd_mode));\n\n\t\tif (yang_dnode_exists(dnode, "bfd-name"))\n\t\t\tvty_out(vty, " bfd-name %s", yang_dnode_get_string(dnode, "bfd-name"));\n\n\t\tif (mhop)\n\t\t\tvty_out(vty, " multihop");\n\n\t\tif (yang_dnode_exists(dnode, "source-addr"))\n\t\t\tvty_out(vty, " local-address %s",\n\t\t\t\tyang_dnode_get_string(dnode, "source-addr"));\n\n\t\tif (strcmp(vrf, VRF_DEFAULT_NAME))\n\t\t\tvty_out(vty, " vrf %s", vrf);\n\n\t\tif (bfd_mode == BFD_MODE_TYPE_SBFD_INIT) {\n\t\t\tif (yang_dnode_exists(dnode, "remote-discr"))\n\t\t\t\tvty_out(vty, " remote-discr %u",\n\t\t\t\t\tyang_dnode_get_uint32(dnode, "remote-discr"));\n\t\t}\n\n\t\tif (yang_dnode_exists(dnode, "srv6-source-ipv6"))\n\t\t\tvty_out(vty, " srv6-source-ipv6 %s",\n\t\t\t\tyang_dnode_get_string(dnode, "srv6-source-ipv6"));\n\n\t\tif (yang_dnode_exists(dnode, "srv6-encap-data")) {\n\t\t\tyang_dnode_iterate(sidlist_show_iter_cb, &iter, dnode, "./srv6-encap-data");\n\t\t\tvty_out(vty, " srv6-encap-data %s", iter.buf);\n\t\t}\n\n\t\tvty_out(vty, "\\n");\n\t}\n}\n\nvoid bfd_cli_show_single_hop_peer(struct vty *vty, const struct lyd_node *dnode,\n\t\t\t\t  bool show_defaults)\n{\n\t_bfd_cli_show_peer(vty, dnode, show_defaults, false, BFD_MODE_TYPE_BFD);\n}\n\nvoid bfd_cli_show_multi_hop_peer(struct vty *vty, const struct lyd_node *dnode,\n\t\t\t\t bool show_defaults)\n{\n\t_bfd_cli_show_peer(vty, dnode, show_defaults, true, BFD_MODE_TYPE_BFD);\n}\n\nvoid bfd_cli_show_sbfd_echo_peer(struct vty *vty, const struct lyd_node *dnode, bool show_defaults)\n{\n\t_bfd_cli_show_peer(vty, dnode, show_defaults, false, BFD_MODE_TYPE_SBFD_ECHO);\n}\n\nvoid bfd_cli_show_sbfd_init_peer(struct vty *vty, const struct lyd_node *dnode, bool show_defaults)\n{\n\t_bfd_cli_show_peer(vty, dnode, show_defaults, true, BFD_MODE_TYPE_SBFD_INIT);\n}\n\nvoid bfd_cli_show_peer_end(struct vty *vty, const struct lyd_node *dnode\n\t\t\t   __attribute__((__unused__)))\n{\n\tvty_out(vty, " exit\\n");\n\tvty_out(vty, " !\\n");\n}\n\nDEFPY_YANG(\n\tbfd_peer_shutdown, bfd_peer_shutdown_cmd,\n\t"[no] shutdown",\n\tNO_STR\n\t"Disable BFD peer\\n")\n{\n\tnb_cli_enqueue_change(vty, "./administrative-down", NB_OP_MODIFY,\n\t\t\t      no ? "false" : "true");\n\treturn nb_cli_apply_changes(vty, NULL);\n}\n\nvoid bfd_cli_show_shutdown(struct vty *vty, const struct lyd_node *dnode,\n\t\t\t   bool show_defaults)\n{\n\tvty_out(vty, "  %sshutdown\\n",\n\t\tyang_dnode_get_bool(dnode, NULL) ? "" : "no ");\n}\n\nDEFPY_YANG(\n\tbfd_peer_passive, bfd_peer_passive_cmd,\n\t"[no] passive-mode",\n\tNO_STR\n\t"Don\'t attempt to start sessions\\n")\n{\n\tnb_cli_enqueue_change(vty, "./passive-mode", NB_OP_MODIFY,\n\t\t\t      no ? "false" : "true");\n\treturn nb_cli_apply_changes(vty, NULL);\n}\n\nvoid bfd_cli_show_passive(struct vty *vty, const struct lyd_node *dnode,\n\t\t\t  bool show_defaults)\n{\n\tvty_out(vty, "  %spassive-mode\\n",\n\t\tyang_dnode_get_bool(dnode, NULL) ? "" : "no ");\n}\n\nDEFPY_YANG(bfd_peer_log_session_changes, bfd_peer_log_session_changes_cmd,\n\t   "[no] log-session-changes",\n\t   NO_STR\n\t   "Log Up/Down changes for the session\\n")\n{\n\tnb_cli_enqueue_change(vty, "./log-session-changes", NB_OP_MODIFY, no ? "false" : "true");\n\treturn nb_cli_apply_changes(vty, NULL);\n}\n\nvoid bfd_cli_show_log_session_changes(struct vty *vty, const struct lyd_node *dnode,\n\t\t\t\t      bool show_defaults)\n{\n\tvty_out(vty, "  %slog-session-changes\\n", yang_dnode_get_bool(dnode, NULL) ? "" : "no ");\n}\n\nDEFPY_YANG(\n\tbfd_peer_minimum_ttl, bfd_peer_minimum_ttl_cmd,\n\t"[no] minimum-ttl (1-254)$ttl",\n\tNO_STR\n\t"Expect packets with at least this TTL\\n"\n\t"Minimum TTL expected\\n")\n{\n\tif (bfd_cli_is_single_hop(vty)) {\n\t\tvty_out(vty, "%% Minimum TTL is only available for multi hop sessions.\\n");\n\t\treturn CMD_WARNING_CONFIG_FAILED;\n\t}\n\n\tif (no)\n\t\tnb_cli_enqueue_change(vty, "./minimum-ttl", NB_OP_DESTROY,\n\t\t\t\t      NULL);\n\telse\n\t\tnb_cli_enqueue_change(vty, "./minimum-ttl", NB_OP_MODIFY,\n\t\t\t\t      ttl_str);\n\treturn nb_cli_apply_changes(vty, NULL);\n}\n\nDEFPY_YANG(\n\tno_bfd_peer_minimum_ttl, no_bfd_peer_minimum_ttl_cmd,\n\t"no minimum-ttl",\n\tNO_STR\n\t"Expect packets with at least this TTL\\n")\n{\n\tnb_cli_enqueue_change(vty, "./minimum-ttl", NB_OP_DESTROY, NULL);\n\treturn nb_cli_apply_changes(vty, NULL);\n}\n\nvoid bfd_cli_show_minimum_ttl(struct vty *vty, const struct lyd_node *dnode,\n\t\t\t      bool show_defaults)\n{\n\tvty_out(vty, "  minimum-ttl %s\\n", yang_dnode_get_string(dnode, NULL));\n}\n\nDEFPY_YANG(\n\tbfd_peer_mult, bfd_peer_mult_cmd,\n\t"[no] detect-multiplier ![(1-255)$multiplier]",\n\tNO_STR\n\t"Configure peer detection multiplier\\n"\n\t"Configure peer detection multiplier value\\n")\n{\n\tnb_cli_enqueue_change(vty, "./detection-multiplier", no ? NB_OP_DESTROY : NB_OP_MODIFY,\n\t\t\t      multiplier_str);\n\treturn nb_cli_apply_changes(vty, NULL);\n}\n\nvoid bfd_cli_show_mult(struct vty *vty, const struct lyd_node *dnode,\n\t\t       bool show_defaults)\n{\n\tvty_out(vty, "  detect-multiplier %s\\n",\n\t\tyang_dnode_get_string(dnode, NULL));\n}\n\nDEFPY_YANG(\n\tbfd_peer_rx, bfd_peer_rx_cmd,\n\t"[no] receive-interval ![(10-4294967)$interval]",\n\tNO_STR\n\t"Configure peer receive interval\\n"\n\t"Configure peer receive interval value in milliseconds\\n")\n{\n\tchar value[32];\n\n\tsnprintfrr(value, sizeof(value), "%" PRId64, interval * 1000);\n\tnb_cli_enqueue_change(vty, "./required-receive-interval", no ? NB_OP_DESTROY : NB_OP_MODIFY,\n\t\t\t      value);\n\n\treturn nb_cli_apply_changes(vty, NULL);\n}\n\nvoid bfd_cli_show_rx(struct vty *vty, const struct lyd_node *dnode,\n\t\t     bool show_defaults)\n{\n\tuint32_t value = yang_dnode_get_uint32(dnode, NULL);\n\n\tvty_out(vty, "  receive-interval %u\\n", value / 1000);\n}\n\nDEFPY_YANG(\n\tbfd_peer_tx, bfd_peer_tx_cmd,\n\t"[no] transmit-interval ![(10-4294967)$interval]",\n\tNO_STR\n\t"Configure peer transmit interval\\n"\n\t"Configure peer transmit interval value in milliseconds\\n")\n{\n\tchar value[32];\n\n\tsnprintfrr(value, sizeof(value), "%" PRId64, interval * 1000);\n\tnb_cli_enqueue_change(vty, "./desired-transmission-interval",\n\t\t\t      no ? NB_OP_DESTROY : NB_OP_MODIFY, value);\n\n\treturn nb_cli_apply_changes(vty, NULL);\n}\n\nvoid bfd_cli_show_tx(struct vty *vty, const struct lyd_node *dnode,\n\t\t     bool show_defaults)\n{\n\tuint32_t value = yang_dnode_get_uint32(dnode, NULL);\n\n\tvty_out(vty, "  transmit-interval %u\\n", value / 1000);\n}\n\nDEFPY_YANG(\n\tbfd_peer_echo, bfd_peer_echo_cmd,\n\t"[no] echo-mode",\n\tNO_STR\n\t"Configure echo mode\\n")\n{\n\tif (!bfd_cli_is_profile(vty) && !bfd_cli_is_single_hop(vty)) {\n\t\tvty_out(vty,\n\t\t\t"%% Echo mode is only available for single hop sessions.\\n");\n\t\treturn CMD_WARNING_CONFIG_FAILED;\n\t}\n\n\tif (!no && !bglobal.bg_use_dplane) {\n#ifdef BFD_LINUX\n\t\tvty_out(vty,\n\t\t\t"%% Echo mode works correctly for IPv4, but only works when the peer is also FRR for IPv6.\\n");\n#else\n\t\tvty_out(vty,\n\t\t\t"%% Current implementation of echo mode works only when the peer is also FRR.\\n");\n#endif /* BFD_LINUX */\n\t}\n\n\tnb_cli_enqueue_change(vty, "./echo-mode", NB_OP_MODIFY,\n\t\t\t      no ? "false" : "true");\n\treturn nb_cli_apply_changes(vty, NULL);\n}\n\nvoid bfd_cli_show_echo(struct vty *vty, const struct lyd_node *dnode,\n\t\t       bool show_defaults)\n{\n\tvty_out(vty, "  %secho-mode\\n",\n\t\tyang_dnode_get_bool(dnode, NULL) ? "" : "no ");\n}\n\nDEFPY_YANG(\n\tbfd_peer_echo_interval, bfd_peer_echo_interval_cmd,\n\t"[no] echo-interval ![(10-4294967)$interval]",\n\tNO_STR\n\t"Configure peer echo intervals\\n"\n\t"Configure peer echo rx/tx intervals value in milliseconds\\n")\n{\n\tchar value[32];\n\n\tif (!bfd_cli_is_profile(vty) && !bfd_cli_is_single_hop(vty) && !bfd_cli_is_sbfd_echo(vty)) {\n\t\tvty_out(vty,\n\t\t\t"%% Echo mode is only available for single hop or sbfd echo sessions.\\n");\n\t\treturn CMD_WARNING_CONFIG_FAILED;\n\t}\n\n\tsnprintfrr(value, sizeof(value), "%" PRId64, interval * 1000);\n\tnb_cli_enqueue_change(vty, "./desired-echo-transmission-interval",\n\t\t\t      no ? NB_OP_DESTROY : NB_OP_MODIFY, value);\n\tnb_cli_enqueue_change(vty, "./required-echo-receive-interval",\n\t\t\t      no ? NB_OP_DESTROY : NB_OP_MODIFY, value);\n\n\treturn nb_cli_apply_changes(vty, NULL);\n}\n\nDEFPY_YANG(\n\tbfd_peer_echo_transmit_interval, bfd_peer_echo_transmit_interval_cmd,\n\t"[no] echo transmit-interval ![(10-4294967)$interval]",\n\tNO_STR\n\t"Configure peer echo intervals\\n"\n\t"Configure desired transmit interval\\n"\n\t"Configure interval value in milliseconds\\n")\n{\n\tchar value[32];\n\n\tif (!bfd_cli_is_profile(vty) && !bfd_cli_is_single_hop(vty) && !bfd_cli_is_sbfd_echo(vty)) {\n\t\tvty_out(vty,\n\t\t\t"%% Echo mode is only available for single hop or sbfd echo sessions.\\n");\n\t\treturn CMD_WARNING_CONFIG_FAILED;\n\t}\n\n\tsnprintfrr(value, sizeof(value), "%" PRId64, interval * 1000);\n\tnb_cli_enqueue_change(vty, "./desired-echo-transmission-interval",\n\t\t\t      no ? NB_OP_DESTROY : NB_OP_MODIFY, value);\n\n\treturn nb_cli_apply_changes(vty, NULL);\n}\n\nvoid bfd_cli_show_desired_echo_transmission_interval(\n\tstruct vty *vty, const struct lyd_node *dnode, bool show_defaults)\n{\n\tuint32_t value = yang_dnode_get_uint32(dnode, NULL);\n\n\tvty_out(vty, "  echo transmit-interval %u\\n", value / 1000);\n}\n\nDEFPY_YANG(\n\tbfd_peer_echo_receive_interval, bfd_peer_echo_receive_interval_cmd,\n\t"[no] echo receive-interval ![<disabled$disabled|(10-4294967)$interval>]",\n\tNO_STR\n\t"Configure peer echo intervals\\n"\n\t"Configure required receive interval\\n"\n\t"Disable echo packets receive\\n"\n\t"Configure interval value in milliseconds\\n")\n{\n\tchar value[32];\n\n\tif (!bfd_cli_is_profile(vty) && !bfd_cli_is_single_hop(vty) && !bfd_cli_is_sbfd_echo(vty)) {\n\t\tvty_out(vty,\n\t\t\t"%% Echo mode is only available for single hop or sbfd echo sessions.\\n");\n\t\treturn CMD_WARNING_CONFIG_FAILED;\n\t}\n\n\n\tif (disabled)\n\t\tsnprintf(value, sizeof(value), "0");\n\telse\n\t\tsnprintfrr(value, sizeof(value), "%" PRId64, interval * 1000);\n\n\tnb_cli_enqueue_change(vty, "./required-echo-receive-interval",\n\t\t\t      no ? NB_OP_DESTROY : NB_OP_MODIFY, value);\n\n\treturn nb_cli_apply_changes(vty, NULL);\n}\n\nvoid bfd_cli_show_required_echo_receive_interval(struct vty *vty,\n\t\t\t\t\t\t const struct lyd_node *dnode,\n\t\t\t\t\t\t bool show_defaults)\n{\n\tuint32_t value = yang_dnode_get_uint32(dnode, NULL);\n\n\tif (value)\n\t\tvty_out(vty, "  echo receive-interval %u\\n", value / 1000);\n\telse\n\t\tvty_out(vty, "  echo receive-interval disabled\\n");\n}\n\n/*\n * Profile commands.\n */\nDEFPY_YANG_NOSH(bfd_profile, bfd_profile_cmd,\n\t   "profile BFDPROF$name",\n\t   BFD_PROFILE_STR\n\t   BFD_PROFILE_NAME_STR)\n{\n\tchar xpath[XPATH_MAXLEN];\n\tint rv;\n\n\tsnprintf(xpath, sizeof(xpath), "/frr-bfdd:bfdd/bfd/profile[name=\'%s\']",\n\t\t name);\n\n\tnb_cli_enqueue_change(vty, xpath, NB_OP_CREATE, NULL);\n\n\t/* Apply settings immediately. */\n\trv = nb_cli_apply_changes(vty, NULL);\n\tif (rv == CMD_SUCCESS)\n\t\tVTY_PUSH_XPATH(BFD_PROFILE_NODE, xpath);\n\n\treturn CMD_SUCCESS;\n}\n\nDEFPY_YANG(no_bfd_profile, no_bfd_profile_cmd,\n      "no profile BFDPROF$name",\n      NO_STR\n      BFD_PROFILE_STR\n      BFD_PROFILE_NAME_STR)\n{\n\tchar xpath[XPATH_MAXLEN];\n\n\tsnprintf(xpath, sizeof(xpath), "/frr-bfdd:bfdd/bfd/profile[name=\'%s\']",\n\t\t name);\n\n\tnb_cli_enqueue_change(vty, xpath, NB_OP_DESTROY, NULL);\n\n\t/* Apply settings immediately. */\n\treturn nb_cli_apply_changes(vty, NULL);\n}\n\nvoid bfd_cli_show_profile(struct vty *vty, const struct lyd_node *dnode,\n\t\t\t  bool show_defaults)\n{\n\tvty_out(vty, " profile %s\\n", yang_dnode_get_string(dnode, "name"));\n}\n\nALIAS_YANG(bfd_peer_mult, bfd_profile_mult_cmd,\n      "[no] detect-multiplier ![(1-255)$multiplier]",\n      NO_STR\n      "Configure peer detection multiplier\\n"\n      "Configure peer detection multiplier value\\n")\n\nALIAS_YANG(bfd_peer_tx, bfd_profile_tx_cmd,\n      "[no] transmit-interval ![(10-4294967)$interval]",\n      NO_STR\n      "Configure peer transmit interval\\n"\n      "Configure peer transmit interval value in milliseconds\\n")\n\nALIAS_YANG(bfd_peer_rx, bfd_profile_rx_cmd,\n      "[no] receive-interval ![(10-4294967)$interval]",\n      NO_STR\n      "Configure peer receive interval\\n"\n      "Configure peer receive interval value in milliseconds\\n")\n\nALIAS_YANG(bfd_peer_shutdown, bfd_profile_shutdown_cmd,\n      "[no] shutdown",\n      NO_STR\n      "Disable BFD peer\\n")\n\nALIAS_YANG(bfd_peer_passive, bfd_profile_passive_cmd,\n      "[no] passive-mode",\n      NO_STR\n      "Don\'t attempt to start sessions\\n")\n\nALIAS_YANG(bfd_peer_log_session_changes, bfd_profile_log_session_changes_cmd,\n\t   "[no] log-session-changes", NO_STR "Log Up/Down session changes in the profile\\n")\n\nALIAS_YANG(bfd_peer_minimum_ttl, bfd_profile_minimum_ttl_cmd,\n      "[no] minimum-ttl (1-254)$ttl",\n      NO_STR\n      "Expect packets with at least this TTL\\n"\n      "Minimum TTL expected\\n")\n\nALIAS_YANG(no_bfd_peer_minimum_ttl, no_bfd_profile_minimum_ttl_cmd,\n      "no minimum-ttl",\n      NO_STR\n      "Expect packets with at least this TTL\\n")\n\nALIAS_YANG(bfd_peer_echo, bfd_profile_echo_cmd,\n      "[no] echo-mode",\n      NO_STR\n      "Configure echo mode\\n")\n\nALIAS_YANG(bfd_peer_echo_interval, bfd_profile_echo_interval_cmd,\n      "[no] echo-interval ![(10-4294967)$interval]",\n      NO_STR\n      "Configure peer echo interval\\n"\n      "Configure peer echo interval value in milliseconds\\n")\n\nALIAS_YANG(\n\tbfd_peer_echo_transmit_interval, bfd_profile_echo_transmit_interval_cmd,\n\t"[no] echo transmit-interval ![(10-4294967)$interval]",\n\tNO_STR\n\t"Configure peer echo intervals\\n"\n\t"Configure desired transmit interval\\n"\n\t"Configure interval value in milliseconds\\n")\n\nALIAS_YANG(\n\tbfd_peer_echo_receive_interval, bfd_profile_echo_receive_interval_cmd,\n\t"[no] echo receive-interval ![<disabled$disabled|(10-4294967)$interval>]",\n\tNO_STR\n\t"Configure peer echo intervals\\n"\n\t"Configure required receive interval\\n"\n\t"Disable echo packets receive\\n"\n\t"Configure interval value in milliseconds\\n")\n\nDEFPY_YANG(bfd_peer_profile, bfd_peer_profile_cmd,\n      "[no] profile BFDPROF$pname",\n      NO_STR\n      "Use BFD profile settings\\n"\n      BFD_PROFILE_NAME_STR)\n{\n\tif (no)\n\t\tnb_cli_enqueue_change(vty, "./profile", NB_OP_DESTROY, NULL);\n\telse\n\t\tnb_cli_enqueue_change(vty, "./profile", NB_OP_MODIFY, pname);\n\n\treturn nb_cli_apply_changes(vty, NULL);\n}\n\nDEFPY(\n\tsbfd_reflector, sbfd_reflector_cmd,\n\t"sbfd reflector source-address X:X::X:X$srcip discriminator WORD...",\n    "seamless BFD\\n"\n    "sbfd reflector\\n"\n\t"binding source ip address\\n"\n\tIPV6_STR\n\t"discriminator\\n"\n\t"discriminator value or range (e.g. 100 or 100 200 300 or 100-300)\\n")\n{\n\tint idx_discr = 5;\n\tint i;\n\tuint32_t j;\n\tuint32_t discr = 0;\n\tuint32_t discr_from = 0;\n\tuint32_t discr_to = 0;\n\n\tfor (i = idx_discr; i < argc; i++) {\n\t\t/* check validity*/\n\t\tchar *pstr = argv[i]->arg;\n\n\t\t/*single discr*/\n\t\tif (strspn(pstr, "0123456789") == strlen(pstr)) {\n\t\t\tdiscr = atol(pstr);\n\t\t\tsbfd_reflector_new(discr, &srcip);\n\t\t}\n\t\t/*discr segment*/\n\t\telse if (strspn(pstr, "0123456789-") == strlen(pstr)) {\n\t\t\tchar *token = strtok(argv[i]->arg, "-");\n\n\t\t\tif (token)\n\t\t\t\tdiscr_from = atol(token);\n\n\t\t\ttoken = strtok(NULL, "-");\n\t\t\tif (token)\n\t\t\t\tdiscr_to = atol(token);\n\n\t\t\tif (discr_from >= discr_to) {\n\t\t\t\tvty_out(vty, "input discriminator range %u-%u is illegal\\n",\n\t\t\t\t\tdiscr_from, discr_to);\n\t\t\t}\n\n\t\t\tfor (j = discr_from; j <= discr_to; j++)\n\t\t\t\tsbfd_reflector_new(j, &srcip);\n\t\t}\n\t\t/*illegal input*/\n\t\telse\n\t\t\tvty_out(vty, "input discriminator %s is illegal\\n", (char *)argv[i]);\n\t}\n\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(\n\tno_sbfd_reflector_all, no_sbfd_reflector_all_cmd,\n\t"no sbfd reflector [all]",\n\tNO_STR\n    "seamless BFD\\n"\n    "sbfd reflector\\n"\n\t"all\\n")\n{\n\tsbfd_reflector_flush();\n\n\tif (sbfd_discr_get_count()) {\n\t\tvty_out(vty, "delete all reflector discriminator failed.\\n");\n\t\treturn CMD_WARNING_CONFIG_FAILED;\n\t}\n\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(\n\tno_sbfd_reflector, no_sbfd_reflector_cmd,\n\t"no sbfd reflector (0-4294967295)$start_discr [(0-4294967295)$end_discr]",\n\tNO_STR\n    "seamless BFD\\n"\n    "sbfd reflector\\n"\n\t"start discriminator\\n"\n\t"end discriminator\\n")\n{\n\tstruct sbfd_reflector *sr;\n\tint32_t i;\n\n\tif (end_discr == 0) {\n\t\tif (start_discr == 0) {\n\t\t\tvty_out(vty, "input reflector discriminator is illegal.\\n");\n\t\t\treturn CMD_WARNING_CONFIG_FAILED;\n\t\t}\n\n\t\tsr = sbfd_discr_lookup(start_discr);\n\t\tif (!sr) {\n\t\t\tvty_out(vty, "input reflector discriminator does not exist.\\n");\n\t\t\treturn CMD_WARNING_CONFIG_FAILED;\n\t\t}\n\n\t\t// notify bfdsyncd\n\t\t//bfd_fpm_sbfd_reflector_sendmsg(sr, false);\n\t\tsbfd_reflector_free(start_discr);\n\n\t} else {\n\t\tif (end_discr <= start_discr) {\n\t\t\tvty_out(vty, "input reflector discriminator is illegal.\\n");\n\t\t\treturn CMD_WARNING_CONFIG_FAILED;\n\t\t}\n\n\t\tfor (i = start_discr; i <= end_discr; i++) {\n\t\t\tsr = sbfd_discr_lookup(i);\n\t\t\tif (sr) {\n\t\t\t\t// notify bfdsyncd\n\t\t\t\t//bfd_fpm_sbfd_reflector_sendmsg(sr, false);\n\t\t\t\tsbfd_reflector_free(i);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn CMD_SUCCESS;\n}\n\nstatic void _sbfd_reflector_show(struct hash_bucket *hb, void *arg)\n{\n\tstruct sbfd_reflector *sr = hb->data;\n\tstruct ttable *tt;\n\tchar buf[INET6_ADDRSTRLEN];\n\n\ttt = (struct ttable *)arg;\n\n\tttable_add_row(tt, "%u|%s|%s|%s", sr->discr,\n\t\t       inet_ntop(AF_INET6, &sr->local, buf, sizeof(buf)), "Active", "Software");\n}\n\nDEFPY(\n\tsbfd_reflector_show_info, sbfd_reflector_show_info_cmd,\n\t"show sbfd reflector",\n\t"show\\n"\n    "seamless BFD\\n"\n    "sbfd reflector\\n")\n{\n\tstruct ttable *tt;\n\tchar *out;\n\n\tvty_out(vty, "sbfd reflector discriminator :\\n");\n\ttt = ttable_new(&ttable_styles[TTSTYLE_BLANK]);\n\tttable_add_row(tt, "SBFD-Discr|SourceIP|State|CreateType");\n\tttable_rowseps(tt, 0, BOTTOM, true, \'-\');\n\n\tsbfd_discr_iterate(_sbfd_reflector_show, tt);\n\n\tout = ttable_dump(tt, "\\n");\n\tvty_out(vty, "%s", out);\n\tXFREE(MTYPE_TMP, out);\n\tttable_del(tt);\n\n\treturn CMD_SUCCESS;\n}\nvoid bfd_cli_peer_profile_show(struct vty *vty, const struct lyd_node *dnode,\n\t\t\t       bool show_defaults)\n{\n\tvty_out(vty, "  profile %s\\n", yang_dnode_get_string(dnode, NULL));\n}\n\n/*\n * Micro-BFD LAG CLI Commands (RFC 7130)\n */\n#include "bfd_lag.h"\n\n#define LAG_STR "Configure Micro-BFD over LAG (RFC 7130)\\n"\n#define LAG_NAME_STR "LAG interface name\\n"\n#define MEMBER_STR "Configure member link\\n"\n#define MEMBER_NAME_STR "Member interface name\\n"\n\nDEFPY_NOSH(bfd_lag_enter, bfd_lag_enter_cmd,\n\t   "lag LAGNAME$lagname [vrf NAME$vrfname]",\n\t   LAG_STR\n\t   LAG_NAME_STR\n\t   VRF_STR\n\t   VRF_NAME_STR)\n{\n\tstruct bfd_lag *lag;\n\n\tlag = bfd_lag_get(lagname, vrfname);\n\tif (lag == NULL) {\n\t\tvty_out(vty, "%% Failed to create LAG %s\\n", lagname);\n\t\treturn CMD_WARNING_CONFIG_FAILED;\n\t}\n\n\tVTY_PUSH_CONTEXT(BFD_LAG_NODE, lag);\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(bfd_no_lag, bfd_no_lag_cmd,\n      "no lag LAGNAME$lagname [vrf NAME$vrfname]",\n      NO_STR\n      LAG_STR\n      LAG_NAME_STR\n      VRF_STR\n      VRF_NAME_STR)\n{\n\tstruct bfd_lag *lag;\n\n\tlag = bfd_lag_find(lagname, vrfname);\n\tif (lag == NULL) {\n\t\tvty_out(vty, "%% Cannot find LAG %s\\n", lagname);\n\t\treturn CMD_WARNING_CONFIG_FAILED;\n\t}\n\n\tbfd_lag_free(lag);\n\treturn CMD_SUCCESS;\n}\n\nDEFPY_NOSH(bfd_lag_member_enter, bfd_lag_member_enter_cmd,\n      "member-link IFNAME$ifname",\n      MEMBER_STR\n      MEMBER_NAME_STR)\n{\n\tVTY_DECLVAR_CONTEXT(bfd_lag, lag);\n\tstruct bfd_lag_member *member;\n\n\tmember = bfd_lag_member_get(lag, ifname);\n\tif (member == NULL) {\n\t\tvty_out(vty, "%% Failed to add member %s to LAG %s\\n",\n\t\t\tifname, lag->lag_name);\n\t\treturn CMD_WARNING_CONFIG_FAILED;\n\t}\n\n\tVTY_PUSH_CONTEXT_SUB(BFD_LAG_MEMBER_NODE, member);\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(bfd_lag_no_member, bfd_lag_no_member_cmd,\n      "no member-link IFNAME$ifname",\n      NO_STR\n      MEMBER_STR\n      MEMBER_NAME_STR)\n{\n\tVTY_DECLVAR_CONTEXT(bfd_lag, lag);\n\tstruct bfd_lag_member *member;\n\n\tmember = bfd_lag_member_find(lag, ifname);\n\tif (member == NULL) {\n\t\tvty_out(vty, "%% Cannot find member %s in LAG %s\\n",\n\t\t\tifname, lag->lag_name);\n\t\treturn CMD_WARNING_CONFIG_FAILED;\n\t}\n\n\tbfd_lag_member_free(member);\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(bfd_lag_mult, bfd_lag_mult_cmd,\n      "[no] detect-multiplier ![(2-255)$mult]",\n      NO_STR\n      "Configure detection multiplier\\n"\n      "Multiplier value\\n")\n{\n\tVTY_DECLVAR_CONTEXT(bfd_lag, lag);\n\n\tif (no)\n\t\tlag->detect_mult = BFD_DEFDETECTMULT;\n\telse\n\t\tlag->detect_mult = mult;\n\n\tbfd_lag_update_timers(lag);\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(bfd_lag_tx, bfd_lag_tx_cmd,\n      "[no] transmit-interval ![(10-4294967)$interval]",\n      NO_STR\n      "Configure transmit interval\\n"\n      "Interval in milliseconds\\n")\n{\n\tVTY_DECLVAR_CONTEXT(bfd_lag, lag);\n\n\tif (no)\n\t\tlag->min_tx = BFD_DEFDESIREDMINTX;\n\telse\n\t\tlag->min_tx = interval * 1000;  /* Convert ms to us */\n\n\tbfd_lag_update_timers(lag);\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(bfd_lag_rx, bfd_lag_rx_cmd,\n      "[no] receive-interval ![(10-4294967)$interval]",\n      NO_STR\n      "Configure receive interval\\n"\n      "Interval in milliseconds\\n")\n{\n\tVTY_DECLVAR_CONTEXT(bfd_lag, lag);\n\n\tif (no)\n\t\tlag->min_rx = BFD_DEFREQUIREDMINRX;\n\telse\n\t\tlag->min_rx = interval * 1000;  /* Convert ms to us */\n\n\tbfd_lag_update_timers(lag);\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(bfd_lag_shutdown, bfd_lag_shutdown_cmd,\n      "[no] shutdown",\n      NO_STR\n      "Administratively disable LAG Micro-BFD\\n")\n{\n\tVTY_DECLVAR_CONTEXT(bfd_lag, lag);\n\n\tbfd_lag_set_shutdown(lag, no ? false : true);\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(bfd_lag_profile, bfd_lag_profile_cmd,\n      "[no] profile BFDPROF$pname",\n      NO_STR\n      "Use BFD profile settings\\n"\n      BFD_PROFILE_NAME_STR)\n{\n\tVTY_DECLVAR_CONTEXT(bfd_lag, lag);\n\n\tif (no)\n\t\tbfd_lag_set_profile(lag, NULL);\n\telse\n\t\tbfd_lag_set_profile(lag, pname);\n\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(bfd_lag_member_local_address, bfd_lag_member_local_address_cmd,\n      "local-address <A.B.C.D|X:X::X:X>$addr",\n      "Configure local address for this member\\n"\n      "IPv4 local address\\n"\n      "IPv6 local address\\n")\n{\n\tVTY_DECLVAR_CONTEXT_SUB(bfd_lag_member, member);\n\tstruct sockaddr_any sa;\n\n\tmemset(&sa, 0, sizeof(sa));\n\tif (addr->sa.sa_family == AF_INET) {\n\t\tsa.sa_sin.sin_family = AF_INET;\n\t\tsa.sa_sin.sin_addr = addr->sin.sin_addr;\n\t} else {\n\t\tsa.sa_sin6.sin6_family = AF_INET6;\n\t\tsa.sa_sin6.sin6_addr = addr->sin6.sin6_addr;\n\t}\n\n\tbfd_lag_member_set_local_address(member, &sa);\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(bfd_lag_member_peer_address, bfd_lag_member_peer_address_cmd,\n      "peer-address <A.B.C.D|X:X::X:X>$addr",\n      "Configure peer address for this member\\n"\n      "IPv4 peer address\\n"\n      "IPv6 peer address\\n")\n{\n\tVTY_DECLVAR_CONTEXT_SUB(bfd_lag_member, member);\n\tstruct sockaddr_any sa;\n\n\tmemset(&sa, 0, sizeof(sa));\n\tif (addr->sa.sa_family == AF_INET) {\n\t\tsa.sa_sin.sin_family = AF_INET;\n\t\tsa.sa_sin.sin_addr = addr->sin.sin_addr;\n\t} else {\n\t\tsa.sa_sin6.sin6_family = AF_INET6;\n\t\tsa.sa_sin6.sin6_addr = addr->sin6.sin6_addr;\n\t}\n\n\tbfd_lag_member_set_peer_address(member, &sa);\n\treturn CMD_SUCCESS;\n}\n\n/* Legacy LAG-level commands that reference member by name (kept for backwards compatibility) */\nDEFPY(bfd_lag_local_address, bfd_lag_local_address_cmd,\n      "local-address <A.B.C.D|X:X::X:X>$addr interface IFNAME$ifname",\n      "Configure local address for member\\n"\n      "IPv4 local address\\n"\n      "IPv6 local address\\n"\n      "Member interface\\n"\n      MEMBER_NAME_STR)\n{\n\tVTY_DECLVAR_CONTEXT(bfd_lag, lag);\n\tstruct bfd_lag_member *member;\n\tstruct sockaddr_any sa;\n\n\tmember = bfd_lag_member_find(lag, ifname);\n\tif (member == NULL) {\n\t\tvty_out(vty, "%% Cannot find member %s in LAG %s\\n",\n\t\t\tifname, lag->lag_name);\n\t\treturn CMD_WARNING_CONFIG_FAILED;\n\t}\n\n\tmemset(&sa, 0, sizeof(sa));\n\tif (addr->sa.sa_family == AF_INET) {\n\t\tsa.sa_sin.sin_family = AF_INET;\n\t\tsa.sa_sin.sin_addr = addr->sin.sin_addr;\n\t} else {\n\t\tsa.sa_sin6.sin6_family = AF_INET6;\n\t\tsa.sa_sin6.sin6_addr = addr->sin6.sin6_addr;\n\t}\n\n\tbfd_lag_member_set_local_address(member, &sa);\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(bfd_lag_peer_address, bfd_lag_peer_address_cmd,\n      "peer-address <A.B.C.D|X:X::X:X>$addr interface IFNAME$ifname",\n      "Configure peer address for member\\n"\n      "IPv4 peer address\\n"\n      "IPv6 peer address\\n"\n      "Member interface\\n"\n      MEMBER_NAME_STR)\n{\n\tVTY_DECLVAR_CONTEXT(bfd_lag, lag);\n\tstruct bfd_lag_member *member;\n\tstruct sockaddr_any sa;\n\n\tmember = bfd_lag_member_find(lag, ifname);\n\tif (member == NULL) {\n\t\tvty_out(vty, "%% Cannot find member %s in LAG %s\\n",\n\t\t\tifname, lag->lag_name);\n\t\treturn CMD_WARNING_CONFIG_FAILED;\n\t}\n\n\tmemset(&sa, 0, sizeof(sa));\n\tif (addr->sa.sa_family == AF_INET) {\n\t\tsa.sa_sin.sin_family = AF_INET;\n\t\tsa.sa_sin.sin_addr = addr->sin.sin_addr;\n\t} else {\n\t\tsa.sa_sin6.sin6_family = AF_INET6;\n\t\tsa.sa_sin6.sin6_addr = addr->sin6.sin6_addr;\n\t}\n\n\tbfd_lag_member_set_peer_address(member, &sa);\n\treturn CMD_SUCCESS;\n}\n\n/* Node definition for BFD LAG */\nstatic int bfd_lag_config_write_node(struct vty *vty);\n\nstruct cmd_node bfd_lag_node = {\n\t.name = "bfd lag",\n\t.node = BFD_LAG_NODE,\n\t.parent_node = BFD_NODE,\n\t.prompt = "%s(config-bfd-lag)# ",\n\t.config_write = bfd_lag_config_write_node,\n};\n\n/* Node definition for BFD LAG member */\nstruct cmd_node bfd_lag_member_node = {\n\t.name = "bfd lag member",\n\t.node = BFD_LAG_MEMBER_NODE,\n\t.parent_node = BFD_LAG_NODE,\n\t.prompt = "%s(config-bfd-lag-member)# ",\n};\n\nstatic int bfd_lag_config_write_node(struct vty *vty)\n{\n\treturn bfd_lag_config_write(vty);\n}\n\nstruct cmd_node bfd_profile_node = {\n\t.name = "bfd profile",\n\t.node = BFD_PROFILE_NODE,\n\t.parent_node = BFD_NODE,\n\t.prompt = "%s(config-bfd-profile)# ",\n};\n\nstatic void bfd_profile_var(vector comps, struct cmd_token *token)\n{\n\textern struct bfdproflist bplist;\n\tstruct bfd_profile *bp;\n\n\tTAILQ_FOREACH (bp, &bplist, entry) {\n\t\tvector_set(comps, XSTRDUP(MTYPE_COMPLETION, bp->name));\n\t}\n}\n\nstatic const struct cmd_variable_handler bfd_vars[] = {\n\t{.tokenname = "BFDPROF", .completions = bfd_profile_var},\n\t{.completions = NULL}\n};\n\nvoid\nbfdd_cli_init(void)\n{\n\tinstall_element(CONFIG_NODE, &bfd_enter_cmd);\n\tinstall_element(CONFIG_NODE, &bfd_config_reset_cmd);\n\n\tinstall_element(BFD_NODE, &bfd_peer_enter_cmd);\n\tinstall_element(BFD_NODE, &bfd_no_peer_cmd);\n\n\tinstall_element(BFD_NODE, &sbfd_echo_peer_enter_cmd);\n\tinstall_element(BFD_NODE, &sbfd_echo_no_peer_cmd);\n\n\tinstall_element(BFD_NODE, &sbfd_init_peer_enter_cmd);\n\tinstall_element(BFD_NODE, &sbfd_init_no_peer_cmd);\n\tinstall_element(BFD_NODE, &sbfd_init_peer_raw_enter_cmd);\n\tinstall_element(BFD_NODE, &sbfd_init_no_peer_raw_cmd);\n\n\tinstall_element(BFD_NODE, &sbfd_reflector_cmd);\n\tinstall_element(BFD_NODE, &no_sbfd_reflector_all_cmd);\n\tinstall_element(BFD_NODE, &no_sbfd_reflector_cmd);\n\tinstall_element(VIEW_NODE, &sbfd_reflector_show_info_cmd);\n\tinstall_element(BFD_PEER_NODE, &bfd_peer_shutdown_cmd);\n\tinstall_element(BFD_PEER_NODE, &bfd_peer_mult_cmd);\n\tinstall_element(BFD_PEER_NODE, &bfd_peer_rx_cmd);\n\tinstall_element(BFD_PEER_NODE, &bfd_peer_tx_cmd);\n\tinstall_element(BFD_PEER_NODE, &bfd_peer_echo_cmd);\n\tinstall_element(BFD_PEER_NODE, &bfd_peer_echo_interval_cmd);\n\tinstall_element(BFD_PEER_NODE, &bfd_peer_echo_transmit_interval_cmd);\n\tinstall_element(BFD_PEER_NODE, &bfd_peer_echo_receive_interval_cmd);\n\tinstall_element(BFD_PEER_NODE, &bfd_peer_profile_cmd);\n\tinstall_element(BFD_PEER_NODE, &bfd_peer_passive_cmd);\n\tinstall_element(BFD_PEER_NODE, &bfd_peer_log_session_changes_cmd);\n\tinstall_element(BFD_PEER_NODE, &bfd_peer_minimum_ttl_cmd);\n\tinstall_element(BFD_PEER_NODE, &no_bfd_peer_minimum_ttl_cmd);\n\n\t/* Profile commands. */\n\tcmd_variable_handler_register(bfd_vars);\n\n\tinstall_node(&bfd_profile_node);\n\tinstall_default(BFD_PROFILE_NODE);\n\n\tinstall_element(BFD_NODE, &bfd_profile_cmd);\n\tinstall_element(BFD_NODE, &no_bfd_profile_cmd);\n\n\tinstall_element(BFD_PROFILE_NODE, &bfd_profile_mult_cmd);\n\tinstall_element(BFD_PROFILE_NODE, &bfd_profile_tx_cmd);\n\tinstall_element(BFD_PROFILE_NODE, &bfd_profile_rx_cmd);\n\tinstall_element(BFD_PROFILE_NODE, &bfd_profile_shutdown_cmd);\n\tinstall_element(BFD_PROFILE_NODE, &bfd_profile_echo_cmd);\n\tinstall_element(BFD_PROFILE_NODE, &bfd_profile_echo_interval_cmd);\n\tinstall_element(BFD_PROFILE_NODE, &bfd_profile_echo_transmit_interval_cmd);\n\tinstall_element(BFD_PROFILE_NODE, &bfd_profile_echo_receive_interval_cmd);\n\tinstall_element(BFD_PROFILE_NODE, &bfd_profile_passive_cmd);\n\tinstall_element(BFD_PROFILE_NODE, &bfd_profile_log_session_changes_cmd);\n\tinstall_element(BFD_PROFILE_NODE, &bfd_profile_minimum_ttl_cmd);\n\tinstall_element(BFD_PROFILE_NODE, &no_bfd_profile_minimum_ttl_cmd);\n\n\t/* Micro-BFD LAG commands (RFC 7130). */\n\tinstall_node(&bfd_lag_node);\n\tinstall_default(BFD_LAG_NODE);\n\n\tinstall_element(BFD_NODE, &bfd_lag_enter_cmd);\n\tinstall_element(BFD_NODE, &bfd_no_lag_cmd);\n\n\tinstall_element(BFD_LAG_NODE, &bfd_lag_member_enter_cmd);\n\tinstall_element(BFD_LAG_NODE, &bfd_lag_no_member_cmd);\n\tinstall_element(BFD_LAG_NODE, &bfd_lag_mult_cmd);\n\tinstall_element(BFD_LAG_NODE, &bfd_lag_tx_cmd);\n\tinstall_element(BFD_LAG_NODE, &bfd_lag_rx_cmd);\n\tinstall_element(BFD_LAG_NODE, &bfd_lag_shutdown_cmd);\n\tinstall_element(BFD_LAG_NODE, &bfd_lag_profile_cmd);\n\t/* Legacy commands that reference member by interface name */\n\tinstall_element(BFD_LAG_NODE, &bfd_lag_local_address_cmd);\n\tinstall_element(BFD_LAG_NODE, &bfd_lag_peer_address_cmd);\n\n\t/* BFD LAG member node (RFC 7130). */\n\tinstall_node(&bfd_lag_member_node);\n\tinstall_default(BFD_LAG_MEMBER_NODE);\n\n\t/* Member-specific commands */\n\tinstall_element(BFD_LAG_MEMBER_NODE, &bfd_lag_member_local_address_cmd);\n\tinstall_element(BFD_LAG_MEMBER_NODE, &bfd_lag_member_peer_address_cmd);\n}\n' : lag command syntax should be correct

  FAIL: test_show_lag_command_defined (__main__.TestMicroBFDCLI)
        File "/home/ubuntu/sonic/frr/tests/bfdd/test_bfd_lag.py", line 329, in test_show_lag_command_defined
        self.assertIn("bfd_show_lag", self.vty_content,
        AssertionError: 'bfd_show_lag' not found in '// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * BFD daemon code\n * Copyright (C) 2018 Network Device Education Foundation, Inc. ("NetDEF")\n */\n\n#include <zebra.h>\n\n#include "lib/command.h"\n#include "lib/json.h"\n#include "lib/log.h"\n#include "lib/northbound_cli.h"\n#include "lib/vty.h"\n\n#include "bfd.h"\n#include "bfd_trace.h"\n\n#include "bfdd/bfdd_vty_clippy.c"\n\n/*\n * Commands help string definitions.\n */\n#define PEER_IPV4_STR "IPv4 peer address\\n"\n#define PEER_IPV6_STR "IPv6 peer address\\n"\n#define MHOP_STR "Configure multihop\\n"\n#define LOCAL_STR "Configure local address\\n"\n#define LOCAL_IPV4_STR "IPv4 local address\\n"\n#define LOCAL_IPV6_STR "IPv6 local address\\n"\n#define LOCAL_INTF_STR "Configure local interface name to use\\n"\n\n/*\n * Prototypes\n */\nstatic int bfd_configure_peer(struct bfd_peer_cfg *bpc, bool mhop,\n\t\t\t      const struct sockaddr_any *peer,\n\t\t\t      const struct sockaddr_any *local,\n\t\t\t      const char *ifname, const char *vrfname,\n\t\t\t      char *ebuf, size_t ebuflen);\n\nstatic void _display_peer_header(struct vty *vty, struct bfd_session *bs);\nstatic struct json_object *__display_peer_json(struct bfd_session *bs);\nstatic struct json_object *_peer_json_header(struct bfd_session *bs);\nstatic void _display_peer_json(struct vty *vty, struct bfd_session *bs);\nstatic void _display_peer(struct vty *vty, struct bfd_session *bs);\nstatic void _display_all_peers(struct vty *vty, char *vrfname, bool use_json);\nstatic void _display_peer_iter(struct hash_bucket *hb, void *arg);\nstatic void _display_peer_json_iter(struct hash_bucket *hb, void *arg);\nstatic void _display_peer_counter(struct vty *vty, struct bfd_session *bs);\nstatic struct json_object *__display_peer_counters_json(struct bfd_session *bs);\nstatic void _display_peer_counters_json(struct vty *vty, struct bfd_session *bs);\nstatic void _display_peer_counter_iter(struct hash_bucket *hb, void *arg);\nstatic void _display_peer_counter_json_iter(struct hash_bucket *hb, void *arg);\nstatic void _display_peers_counter(struct vty *vty, char *vrfname, bool use_json);\nstatic void _display_rtt(uint32_t *min, uint32_t *avg, uint32_t *max,\n\t\t\t struct bfd_session *bs);\n\nstatic struct bfd_session *\n_find_peer_or_error(struct vty *vty, int argc, struct cmd_token **argv,\n\t\t    const char *label, const char *peer_str,\n\t\t    const char *local_str, const char *ifname,\n\t\t    const char *vrfname);\nstatic void _display_bfd_by_bfdname_json_iter(struct hash_bucket *hb, void *arg);\nstatic void _display_bfd_by_bfdname_iter(struct hash_bucket *hb, void *arg);\nstatic void _display_bfd_by_bfdname(struct vty *vty, const char *vrfname, const char *bfdname,\n\t\t\t\t    bool use_json);\nstatic void _display_bfd_counters_by_bfdname_iter(struct hash_bucket *hb, void *arg);\nstatic void _display_bfd_counters_json_by_bfdname_iter(struct hash_bucket *hb, void *arg);\nstatic void _display_bfd_counters_by_bfdname(struct vty *vty, const char *vrfname,\n\t\t\t\t\t     const char *bfdname, bool use_json);\nstatic void _clear_bfd_counters_by_bfdname(const char *vrfname, const char *bfdname);\nstatic void _clear_peer_counter(struct bfd_session *bs);\n\nstatic const char *bfd_mode_type_to_string(enum bfd_mode_type mode)\n{\n\tswitch (mode) {\n\tcase BFD_MODE_TYPE_BFD:\n\t\treturn "bfd";\n\tcase BFD_MODE_TYPE_SBFD_ECHO:\n\t\treturn "sbfd-echo";\n\tcase BFD_MODE_TYPE_SBFD_INIT:\n\t\treturn "sbfd-init";\n\tdefault:\n\t\treturn "Unknown";\n\t}\n}\n\nstatic char *sbfd_sidlist_to_string(struct in6_addr *sidlist, uint8_t segnum)\n{\n\tstatic char buf[INET6_ADDRSTRLEN * SRV6_MAX_SEGS];\n\tint pos = 0;\n\tuint8_t i = 0;\n\tchar addr_buf[INET6_ADDRSTRLEN];\n\n\tmemset(buf, 0, 256);\n\n\tpos = snprintf(buf, sizeof(buf), "%s",\n\t\t       inet_ntop(AF_INET6, &sidlist[0], addr_buf, sizeof(addr_buf)));\n\n\tfor (i = 1; i < segnum; i++)\n\t\tpos += snprintf(buf + pos, sizeof(buf) - pos, " %s",\n\t\t\t\tinet_ntop(AF_INET6, &sidlist[i], addr_buf, sizeof(addr_buf)));\n\n\treturn buf;\n}\n\n/*\n * Show commands helper functions\n */\nstatic void _display_peer_header(struct vty *vty, struct bfd_session *bs)\n{\n\tchar addr_buf[INET6_ADDRSTRLEN];\n\n\tvty_out(vty, "\\tpeer %s",\n\t\tinet_ntop(bs->key.family, &bs->key.peer, addr_buf,\n\t\t\t  sizeof(addr_buf)));\n\n\tif (bs->bfd_mode == BFD_MODE_TYPE_SBFD_ECHO || bs->bfd_mode == BFD_MODE_TYPE_SBFD_INIT)\n\t\tvty_out(vty, " bfd-mode %s", bfd_mode_type_to_string(bs->bfd_mode));\n\n\tif (bs->bfd_name[0])\n\t\tvty_out(vty, " bfd-name %s", bs->bfd_name);\n\n\tif (CHECK_FLAG(bs->flags, BFD_SESS_FLAG_MH))\n\t\tvty_out(vty, " multihop");\n\n\tif (memcmp(&bs->key.local, &zero_addr, sizeof(bs->key.local)))\n\t\tvty_out(vty, " local-address %s",\n\t\t\tinet_ntop(bs->key.family, &bs->key.local, addr_buf,\n\t\t\t\t  sizeof(addr_buf)));\n\n\tif (bs->key.vrfname[0])\n\t\tvty_out(vty, " vrf %s", bs->key.vrfname);\n\tif (bs->key.ifname[0])\n\t\tvty_out(vty, " interface %s", bs->key.ifname);\n\n\tif (bs->bfd_mode == BFD_MODE_TYPE_SBFD_ECHO || bs->bfd_mode == BFD_MODE_TYPE_SBFD_INIT) {\n\t\tif (bs->bfd_mode == BFD_MODE_TYPE_SBFD_INIT)\n\t\t\tvty_out(vty, " remote-discr %u", bs->discrs.remote_discr);\n\n\t\tif (bs->bfd_name[0] && bs->segnum) {\n\t\t\tvty_out(vty, " srv6-source-ipv6 %s",\n\t\t\t\tinet_ntop(AF_INET6, &bs->out_sip6, addr_buf, sizeof(addr_buf)));\n\n\t\t\tvty_out(vty, " srv6-encap-data %s",\n\t\t\t\tsbfd_sidlist_to_string(bs->seg_list, bs->segnum));\n\t\t}\n\t}\n\n\tvty_out(vty, "\\n");\n}\n\nstatic void _display_peer(struct vty *vty, struct bfd_session *bs)\n{\n\tchar buf[256];\n\ttime_t now;\n\tuint32_t min = 0;\n\tuint32_t avg = 0;\n\tuint32_t max = 0;\n\n\t_display_peer_header(vty, bs);\n\n\tvty_out(vty, "\\t\\tID: %u\\n", bs->discrs.my_discr);\n\tvty_out(vty, "\\t\\tRemote ID: %u\\n", bs->discrs.remote_discr);\n\tif (CHECK_FLAG(bs->flags, BFD_SESS_FLAG_PASSIVE))\n\t\tvty_out(vty, "\\t\\tPassive mode\\n");\n\telse\n\t\tvty_out(vty, "\\t\\tActive mode\\n");\n\tif (CHECK_FLAG(bs->flags, BFD_SESS_FLAG_LOG_SESSION_CHANGES))\n\t\tvty_out(vty, "\\t\\tLog session changes\\n");\n\tif (CHECK_FLAG(bs->flags, BFD_SESS_FLAG_MH))\n\t\tvty_out(vty, "\\t\\tMinimum TTL: %d\\n", bs->mh_ttl);\n\tvty_out(vty, "\\t\\tStatus: ");\n\tswitch (bs->ses_state) {\n\tcase PTM_BFD_ADM_DOWN:\n\t\tvty_out(vty, "shutdown\\n");\n\t\tbreak;\n\tcase PTM_BFD_DOWN:\n\t\tvty_out(vty, "down\\n");\n\n\t\tnow = monotime(NULL);\n\t\tinteger2timestr(now - bs->downtime.tv_sec, buf, sizeof(buf));\n\t\tvty_out(vty, "\\t\\tDowntime: %s\\n", buf);\n\t\tbreak;\n\tcase PTM_BFD_INIT:\n\t\tvty_out(vty, "init\\n");\n\t\tbreak;\n\tcase PTM_BFD_UP:\n\t\tvty_out(vty, "up\\n");\n\n\t\tnow = monotime(NULL);\n\t\tinteger2timestr(now - bs->uptime.tv_sec, buf, sizeof(buf));\n\t\tvty_out(vty, "\\t\\tUptime: %s\\n", buf);\n\t\tbreak;\n\n\tdefault:\n\t\tvty_out(vty, "unknown\\n");\n\t\tbreak;\n\t}\n\n\tvty_out(vty, "\\t\\tDiagnostics: %s\\n", diag2str(bs->local_diag));\n\tvty_out(vty, "\\t\\tRemote diagnostics: %s\\n", diag2str(bs->remote_diag));\n\tif (bs->bfd_mode == BFD_MODE_TYPE_SBFD_INIT) {\n\t\tvty_out(vty, "\\t\\tPeer Type: sbfd initiator\\n");\n\t} else if (bs->bfd_mode == BFD_MODE_TYPE_SBFD_ECHO) {\n\t\tvty_out(vty, "\\t\\tPeer Type: echo\\n");\n\t} else {\n\t\tvty_out(vty, "\\t\\tPeer Type: %s\\n",\n\t\t\tCHECK_FLAG(bs->flags, BFD_SESS_FLAG_CONFIG) ? "configured" : "dynamic");\n\t\t_display_rtt(&min, &avg, &max, bs);\n\t\tvty_out(vty, "\\t\\tRTT min/avg/max: %u/%u/%u usec\\n", min, avg, max);\n\t}\n\n\tvty_out(vty, "\\t\\tLocal timers:\\n");\n\tvty_out(vty, "\\t\\t\\tDetect-multiplier: %u\\n",\n\t\tbs->detect_mult);\n\tvty_out(vty, "\\t\\t\\tReceive interval: %ums\\n",\n\t\tbs->timers.required_min_rx / 1000);\n\tvty_out(vty, "\\t\\t\\tTransmission interval: %ums\\n",\n\t\tbs->timers.desired_min_tx / 1000);\n\tif (bs->xmt_TO_actual > 0)\n\t\tvty_out(vty, "\\t\\t\\tTransmission interval (actual with jitter): %" PRIu64 "ms\\n",\n\t\t\tbs->xmt_TO_actual / 1000);\n\tif (bs->detect_TO > 0)\n\t\tvty_out(vty, "\\t\\t\\tDetection timeout: %" PRIu64 "ms\\n",\n\t\t\tbs->detect_TO / 1000);\n\tif (bs->timers.required_min_echo_rx != 0)\n\t\tvty_out(vty, "\\t\\t\\tEcho receive interval: %ums\\n",\n\t\t\tbs->timers.required_min_echo_rx / 1000);\n\telse\n\t\tvty_out(vty, "\\t\\t\\tEcho receive interval: disabled\\n");\n\tif (CHECK_FLAG(bs->flags, BFD_SESS_FLAG_ECHO) || bs->bfd_mode == BFD_MODE_TYPE_SBFD_ECHO) {\n\t\tvty_out(vty, "\\t\\t\\tEcho transmission interval: %ums\\n",\n\t\t\tbs->timers.desired_min_echo_tx / 1000);\n\t\tif (bs->echo_xmt_TO_actual > 0)\n\t\t\tvty_out(vty,\n\t\t\t\t"\\t\\t\\tEcho transmission interval (actual with jitter): %" PRIu64\n\t\t\t\t"ms\\n",\n\t\t\t\tbs->echo_xmt_TO_actual / 1000);\n\t} else\n\t\tvty_out(vty, "\\t\\t\\tEcho transmission interval: disabled\\n");\n\n\n\tif (bs->bfd_mode == BFD_MODE_TYPE_SBFD_INIT || bs->bfd_mode == BFD_MODE_TYPE_SBFD_ECHO) {\n\t\tvty_out(vty, "\\t\\tRemote timers:\\n");\n\t\tvty_out(vty, "\\t\\t\\tDetect-multiplier: -\\n");\n\t\tvty_out(vty, "\\t\\t\\tReceive interval: -\\n");\n\t\tvty_out(vty, "\\t\\t\\tTransmission interval: -\\n");\n\t\tvty_out(vty, "\\t\\t\\tEcho receive interval: -\\n");\n\t} else {\n\t\tvty_out(vty, "\\t\\tRemote timers:\\n");\n\t\tvty_out(vty, "\\t\\t\\tDetect-multiplier: %u\\n", bs->remote_detect_mult);\n\t\tvty_out(vty, "\\t\\t\\tReceive interval: %ums\\n",\n\t\t\tbs->remote_timers.required_min_rx / 1000);\n\t\tvty_out(vty, "\\t\\t\\tTransmission interval: %ums\\n",\n\t\t\tbs->remote_timers.desired_min_tx / 1000);\n\t\tif (bs->remote_timers.required_min_echo != 0)\n\t\t\tvty_out(vty, "\\t\\t\\tEcho receive interval: %ums\\n",\n\t\t\t\tbs->remote_timers.required_min_echo / 1000);\n\t\telse\n\t\t\tvty_out(vty, "\\t\\t\\tEcho receive interval: disabled\\n");\n\t}\n\n\tvty_out(vty, "\\n");\n}\n\nstatic struct json_object *_peer_json_header(struct bfd_session *bs)\n{\n\tstruct json_object *jo = json_object_new_object();\n\tchar addr_buf[INET6_ADDRSTRLEN];\n\n\tif (bs->key.mhop)\n\t\tjson_object_boolean_true_add(jo, "multihop");\n\telse\n\t\tjson_object_boolean_false_add(jo, "multihop");\n\n\tjson_object_string_add(jo, "peer",\n\t\t\t       inet_ntop(bs->key.family, &bs->key.peer,\n\t\t\t\t\t addr_buf, sizeof(addr_buf)));\n\tif (memcmp(&bs->key.local, &zero_addr, sizeof(bs->key.local)))\n\t\tjson_object_string_add(jo, "local",\n\t\t\t\t       inet_ntop(bs->key.family, &bs->key.local,\n\t\t\t\t\t\t addr_buf, sizeof(addr_buf)));\n\n\tif (bs->key.vrfname[0])\n\t\tjson_object_string_add(jo, "vrf", bs->key.vrfname);\n\tif (bs->key.ifname[0])\n\t\tjson_object_string_add(jo, "interface", bs->key.ifname);\n\n\treturn jo;\n}\n\nstatic struct json_object *__display_peer_json(struct bfd_session *bs)\n{\n\tstruct json_object *jo = _peer_json_header(bs);\n\tuint32_t min = 0;\n\tuint32_t avg = 0;\n\tuint32_t max = 0;\n\n\tif (bs->key.ifname[0])\n\t\tjson_object_string_add(jo, "interface", bs->key.ifname);\n\tjson_object_int_add(jo, "id", bs->discrs.my_discr);\n\tjson_object_int_add(jo, "remote-id", bs->discrs.remote_discr);\n\tjson_object_boolean_add(jo, "passive-mode",\n\t\t\t\tCHECK_FLAG(bs->flags, BFD_SESS_FLAG_PASSIVE));\n\tjson_object_boolean_add(jo, "log-session-changes",\n\t\t\t\tCHECK_FLAG(bs->flags, BFD_SESS_FLAG_LOG_SESSION_CHANGES));\n\tif (CHECK_FLAG(bs->flags, BFD_SESS_FLAG_MH))\n\t\tjson_object_int_add(jo, "minimum-ttl", bs->mh_ttl);\n\n\tif (bs->bfd_mode != BFD_MODE_TYPE_BFD)\n\t\tjson_object_string_add(jo, "bfd-name", bs->bfd_name);\n\n\tswitch (bs->ses_state) {\n\tcase PTM_BFD_ADM_DOWN:\n\t\tjson_object_string_add(jo, "status", "shutdown");\n\t\tbreak;\n\tcase PTM_BFD_DOWN:\n\t\tjson_object_string_add(jo, "status", "down");\n\t\tjson_object_int_add(jo, "downtime",\n\t\t\t\t    monotime(NULL) - bs->downtime.tv_sec);\n\t\tbreak;\n\tcase PTM_BFD_INIT:\n\t\tjson_object_string_add(jo, "status", "init");\n\t\tbreak;\n\tcase PTM_BFD_UP:\n\t\tjson_object_string_add(jo, "status", "up");\n\t\tjson_object_int_add(jo, "uptime",\n\t\t\t\t    monotime(NULL) - bs->uptime.tv_sec);\n\t\tbreak;\n\n\tdefault:\n\t\tjson_object_string_add(jo, "status", "unknown");\n\t\tbreak;\n\t}\n\n\tjson_object_string_add(jo, "diagnostic", diag2str(bs->local_diag));\n\tjson_object_string_add(jo, "remote-diagnostic",\n\t\t\t       diag2str(bs->remote_diag));\n\tif (CHECK_FLAG(bs->flags, BFD_SESS_FLAG_CONFIG))\n\t\tjson_object_string_add(jo, "type", "configured");\n\telse\n\t\tjson_object_string_add(jo, "type", "dynamic");\n\n\tjson_object_int_add(jo, "receive-interval",\n\t\t\t    bs->timers.required_min_rx / 1000);\n\tjson_object_int_add(jo, "transmit-interval",\n\t\t\t    bs->timers.desired_min_tx / 1000);\n\tif (bs->xmt_TO_actual > 0)\n\t\tjson_object_int_add(jo, "transmit-interval-actual",\n\t\t\t\t    bs->xmt_TO_actual / 1000);\n\tif (bs->detect_TO > 0)\n\t\tjson_object_int_add(jo, "detection-timeout",\n\t\t\t\t    bs->detect_TO / 1000);\n\tjson_object_int_add(jo, "echo-receive-interval",\n\t\t\t    bs->timers.required_min_echo_rx / 1000);\n\tif (bs->bfd_mode == BFD_MODE_TYPE_SBFD_INIT || bs->bfd_mode == BFD_MODE_TYPE_SBFD_ECHO) {\n\t\tjson_object_int_add(jo, "configured-echo-transmit-interval",\n\t\t\t\t    bs->timers.desired_min_echo_tx / 1000);\n\t\tjson_object_int_add(jo, "current-echo-transmit-interval", bs->echo_xmt_TO / 1000);\n\t\tjson_object_int_add(jo, "current-detect-echo-receive-interval",\n\t\t\t\t    bs->echo_detect_TO / 1000);\n\t} else if (CHECK_FLAG(bs->flags, BFD_SESS_FLAG_ECHO))\n\t\tjson_object_int_add(jo, "echo-transmit-interval",\n\t\t\t\t    bs->timers.desired_min_echo_tx / 1000);\n\telse\n\t\tjson_object_int_add(jo, "echo-transmit-interval", 0);\n\n\tjson_object_int_add(jo, "detect-multiplier", bs->detect_mult);\n\n\tjson_object_int_add(jo, "remote-receive-interval",\n\t\t\t    bs->remote_timers.required_min_rx / 1000);\n\tjson_object_int_add(jo, "remote-transmit-interval",\n\t\t\t    bs->remote_timers.desired_min_tx / 1000);\n\tjson_object_int_add(jo, "remote-echo-receive-interval",\n\t\t\t    bs->remote_timers.required_min_echo / 1000);\n\tjson_object_int_add(jo, "remote-detect-multiplier",\n\t\t\t    bs->remote_detect_mult);\n\n\t_display_rtt(&min, &avg, &max, bs);\n\tjson_object_int_add(jo, "rtt-min", min);\n\tjson_object_int_add(jo, "rtt-avg", avg);\n\tjson_object_int_add(jo, "rtt-max", max);\n\n\treturn jo;\n}\n\nstatic void _display_peer_json(struct vty *vty, struct bfd_session *bs)\n{\n\tstruct json_object *jo = __display_peer_json(bs);\n\n\tvty_json(vty, jo);\n}\n\nstruct bfd_vrf_tuple {\n\tconst char *vrfname;\n\tstruct vty *vty;\n\tstruct json_object *jo;\n\tconst char *bfdname;\n};\n\nstatic void _display_peer_iter(struct hash_bucket *hb, void *arg)\n{\n\tstruct bfd_vrf_tuple *bvt = (struct bfd_vrf_tuple *)arg;\n\tstruct vty *vty;\n\tstruct bfd_session *bs = hb->data;\n\n\tif (!bvt)\n\t\treturn;\n\tvty = bvt->vty;\n\n\tif (bvt->vrfname) {\n\t\tif (!bs->key.vrfname[0] ||\n\t\t    !strmatch(bs->key.vrfname, bvt->vrfname))\n\t\t\treturn;\n\t}\n\t_display_peer(vty, bs);\n}\n\nstatic void _display_bfd_by_bfdname_iter(struct hash_bucket *hb, void *arg)\n{\n\tstruct bfd_vrf_tuple *bvt = (struct bfd_vrf_tuple *)arg;\n\tstruct vty *vty;\n\tstruct bfd_session *bs = hb->data;\n\n\tif (!bvt)\n\t\treturn;\n\tvty = bvt->vty;\n\n\tif (bvt->vrfname) {\n\t\tif (!bs->key.vrfname[0] || !strmatch(bs->key.vrfname, bvt->vrfname))\n\t\t\treturn;\n\t}\n\n\tif (bvt->bfdname) {\n\t\tif ((!bs->key.bfdname[0] || !strmatch(bs->key.bfdname, bvt->bfdname)) &&\n\t\t    (!bs->bfd_name[0] || !strmatch(bs->bfd_name, bvt->bfdname)))\n\t\t\treturn;\n\t}\n\n\t_display_peer(vty, bs);\n}\n\nstatic void _display_peer_json_iter(struct hash_bucket *hb, void *arg)\n{\n\tstruct bfd_vrf_tuple *bvt = (struct bfd_vrf_tuple *)arg;\n\tstruct json_object *jo, *jon = NULL;\n\tstruct bfd_session *bs = hb->data;\n\n\tif (!bvt)\n\t\treturn;\n\tjo = bvt->jo;\n\n\tif (bvt->vrfname) {\n\t\tif (!bs->key.vrfname[0] ||\n\t\t    !strmatch(bs->key.vrfname, bvt->vrfname))\n\t\t\treturn;\n\t}\n\n\tjon = __display_peer_json(bs);\n\tif (jon == NULL) {\n\t\tzlog_warn("%s: not enough memory", __func__);\n\t\treturn;\n\t}\n\n\tjson_object_array_add(jo, jon);\n}\n\nstatic void _display_bfd_by_bfdname_json_iter(struct hash_bucket *hb, void *arg)\n{\n\tstruct bfd_vrf_tuple *bvt = (struct bfd_vrf_tuple *)arg;\n\tstruct json_object *jo, *jon = NULL;\n\tstruct bfd_session *bs = hb->data;\n\n\tif (!bvt)\n\t\treturn;\n\tjo = bvt->jo;\n\n\tif (bvt->vrfname) {\n\t\tif (!bs->key.vrfname[0] || !strmatch(bs->key.vrfname, bvt->vrfname))\n\t\t\treturn;\n\t}\n\n\tif (bvt->bfdname) {\n\t\tif ((!bs->key.bfdname[0] || !strmatch(bs->key.bfdname, bvt->bfdname)) &&\n\t\t    (!bs->bfd_name[0] || !strmatch(bs->bfd_name, bvt->bfdname)))\n\t\t\treturn;\n\t}\n\n\tjon = __display_peer_json(bs);\n\tif (jon == NULL) {\n\t\tzlog_warn("%s: not enough memory", __func__);\n\t\treturn;\n\t}\n\n\tjson_object_array_add(jo, jon);\n}\nstatic void _display_bfd_by_bfdname(struct vty *vty, const char *vrfname, const char *bfdname,\n\t\t\t\t    bool use_json)\n{\n\tstruct json_object *jo;\n\tstruct bfd_vrf_tuple bvt = { 0 };\n\n\tbvt.vrfname = vrfname;\n\tbvt.bfdname = bfdname;\n\n\tif (!use_json) {\n\t\tbvt.vty = vty;\n\t\tvty_out(vty, "BFD Peers:\\n");\n\t\tbfd_id_iterate(_display_bfd_by_bfdname_iter, &bvt);\n\t\treturn;\n\t}\n\n\tjo = json_object_new_array();\n\tbvt.jo = jo;\n\tbfd_id_iterate(_display_bfd_by_bfdname_json_iter, &bvt);\n\n\tvty_json(vty, jo);\n}\n\nstatic void _display_all_peers(struct vty *vty, char *vrfname, bool use_json)\n{\n\tstruct json_object *jo;\n\tstruct bfd_vrf_tuple bvt = {0};\n\n\tbvt.vrfname = vrfname;\n\n\tif (!use_json) {\n\t\tbvt.vty = vty;\n\t\tvty_out(vty, "BFD Peers:\\n");\n\t\tbfd_id_iterate(_display_peer_iter, &bvt);\n\t\treturn;\n\t}\n\n\tjo = json_object_new_array();\n\tbvt.jo = jo;\n\tbfd_id_iterate(_display_peer_json_iter, &bvt);\n\n\tvty_json(vty, jo);\n}\n\nstatic void _display_peer_counter(struct vty *vty, struct bfd_session *bs)\n{\n\t_display_peer_header(vty, bs);\n\n\t/* Ask data plane for updated counters. */\n\tif (bfd_dplane_update_session_counters(bs) == -1) {\n\t\tzlog_debug("%s: failed to update BFD session counters (%s)",\n\t\t\t   __func__, bs_to_string(bs));\n\t\tfrrtrace(3, frr_bfd, stats_error, 1, bs->discrs.my_discr, -1);\n\t}\n\n\tvty_out(vty, "\\t\\tID: %u\\n", bs->discrs.my_discr);\n\tvty_out(vty, "\\t\\tControl packet input: %" PRIu64 " packets\\n",\n\t\tbs->stats.rx_ctrl_pkt);\n\tvty_out(vty, "\\t\\tControl packet output: %" PRIu64 " packets\\n",\n\t\tbs->stats.tx_ctrl_pkt);\n\tvty_out(vty, "\\t\\tEcho packet input: %" PRIu64 " packets\\n",\n\t\tbs->stats.rx_echo_pkt);\n\tvty_out(vty, "\\t\\tEcho packet output: %" PRIu64 " packets\\n",\n\t\tbs->stats.tx_echo_pkt);\n\tvty_out(vty, "\\t\\tSession up events: %" PRIu64 "\\n",\n\t\tbs->stats.session_up);\n\tvty_out(vty, "\\t\\tSession down events: %" PRIu64 "\\n",\n\t\tbs->stats.session_down);\n\tvty_out(vty, "\\t\\tZebra notifications: %" PRIu64 "\\n",\n\t\tbs->stats.znotification);\n\tvty_out(vty, "\\t\\tTx fail packet: %" PRIu64 "\\n", bs->stats.tx_fail_pkt);\n\tvty_out(vty, "\\n");\n}\n\nstatic struct json_object *__display_peer_counters_json(struct bfd_session *bs)\n{\n\tstruct json_object *jo = _peer_json_header(bs);\n\n\t/* Ask data plane for updated counters. */\n\tif (bfd_dplane_update_session_counters(bs) == -1) {\n\t\tzlog_debug("%s: failed to update BFD session counters (%s)",\n\t\t\t   __func__, bs_to_string(bs));\n\t\tfrrtrace(3, frr_bfd, stats_error, 1, bs->discrs.my_discr, -1);\n\t}\n\n\tjson_object_int_add(jo, "id", bs->discrs.my_discr);\n\tjson_object_int_add(jo, "control-packet-input", bs->stats.rx_ctrl_pkt);\n\tjson_object_int_add(jo, "control-packet-output", bs->stats.tx_ctrl_pkt);\n\tjson_object_int_add(jo, "echo-packet-input", bs->stats.rx_echo_pkt);\n\tjson_object_int_add(jo, "echo-packet-output", bs->stats.tx_echo_pkt);\n\tjson_object_int_add(jo, "session-up", bs->stats.session_up);\n\tjson_object_int_add(jo, "session-down", bs->stats.session_down);\n\tjson_object_int_add(jo, "zebra-notifications", bs->stats.znotification);\n\n\tif (bs->bfd_mode == BFD_MODE_TYPE_SBFD_INIT || bs->bfd_mode == BFD_MODE_TYPE_SBFD_ECHO)\n\t\tjson_object_int_add(jo, "tx-fail-packet", bs->stats.tx_fail_pkt);\n\n\treturn jo;\n}\n\nstatic void _display_peer_counters_json(struct vty *vty, struct bfd_session *bs)\n{\n\tstruct json_object *jo = __display_peer_counters_json(bs);\n\n\tvty_json(vty, jo);\n}\n\nstatic void _display_peer_counter_iter(struct hash_bucket *hb, void *arg)\n{\n\tstruct bfd_vrf_tuple *bvt = arg;\n\tstruct vty *vty;\n\tstruct bfd_session *bs = hb->data;\n\n\tif (!bvt)\n\t\treturn;\n\tvty = bvt->vty;\n\n\tif (bvt->vrfname) {\n\t\tif (!bs->key.vrfname[0] ||\n\t\t    !strmatch(bs->key.vrfname, bvt->vrfname))\n\t\t\treturn;\n\t}\n\n\t_display_peer_counter(vty, bs);\n}\n\nstatic void _display_peer_counter_json_iter(struct hash_bucket *hb, void *arg)\n{\n\tstruct json_object *jo, *jon = NULL;\n\tstruct bfd_session *bs = hb->data;\n\tstruct bfd_vrf_tuple *bvt = arg;\n\n\tif (!bvt)\n\t\treturn;\n\tjo  = bvt->jo;\n\n\tif (bvt->vrfname) {\n\t\tif (!bs->key.vrfname[0] ||\n\t\t    !strmatch(bs->key.vrfname, bvt->vrfname))\n\t\t\treturn;\n\t}\n\n\tjon = __display_peer_counters_json(bs);\n\tif (jon == NULL) {\n\t\tzlog_warn("%s: not enough memory", __func__);\n\t\treturn;\n\t}\n\n\tjson_object_array_add(jo, jon);\n}\n\nstatic void _display_peers_counter(struct vty *vty, char *vrfname, bool use_json)\n{\n\tstruct json_object *jo;\n\tstruct bfd_vrf_tuple bvt = {0};\n\n\tbvt.vrfname = vrfname;\n\tif (!use_json) {\n\t\tbvt.vty = vty;\n\t\tvty_out(vty, "BFD Peers:\\n");\n\t\tbfd_id_iterate(_display_peer_counter_iter, &bvt);\n\t\treturn;\n\t}\n\n\tjo = json_object_new_array();\n\tbvt.jo = jo;\n\tbfd_id_iterate(_display_peer_counter_json_iter, &bvt);\n\n\tvty_json(vty, jo);\n}\n\nstatic void _display_bfd_counters_by_bfdname_iter(struct hash_bucket *hb, void *arg)\n{\n\tstruct bfd_vrf_tuple *bvt = arg;\n\tstruct vty *vty;\n\tstruct bfd_session *bs = hb->data;\n\n\tif (!bvt)\n\t\treturn;\n\tvty = bvt->vty;\n\n\tif (bvt->vrfname) {\n\t\tif (!bs->key.vrfname[0] || !strmatch(bs->key.vrfname, bvt->vrfname))\n\t\t\treturn;\n\t}\n\n\tif (bvt->bfdname) {\n\t\tif (!bs->key.bfdname[0] || !strmatch(bs->key.bfdname, bvt->bfdname))\n\t\t\treturn;\n\t}\n\n\t_display_peer_counter(vty, bs);\n}\nstatic void _display_bfd_counters_json_by_bfdname_iter(struct hash_bucket *hb, void *arg)\n{\n\tstruct json_object *jo, *jon = NULL;\n\tstruct bfd_session *bs = hb->data;\n\tstruct bfd_vrf_tuple *bvt = arg;\n\n\tif (!bvt)\n\t\treturn;\n\tjo = bvt->jo;\n\n\tif (bvt->vrfname) {\n\t\tif (!bs->key.vrfname[0] || !strmatch(bs->key.vrfname, bvt->vrfname))\n\t\t\treturn;\n\t}\n\n\tif (bvt->bfdname) {\n\t\tif (!bs->key.bfdname[0] || !strmatch(bs->key.bfdname, bvt->bfdname))\n\t\t\treturn;\n\t}\n\n\tjon = __display_peer_counters_json(bs);\n\tif (jon == NULL) {\n\t\tzlog_warn("%s: not enough memory", __func__);\n\t\treturn;\n\t}\n\n\tjson_object_array_add(jo, jon);\n}\nstatic void _display_bfd_counters_by_bfdname(struct vty *vty, const char *vrfname,\n\t\t\t\t\t     const char *bfdname, bool use_json)\n{\n\tstruct json_object *jo;\n\tstruct bfd_vrf_tuple bvt = { 0 };\n\n\tbvt.vrfname = vrfname;\n\tbvt.bfdname = bfdname;\n\n\tif (!use_json) {\n\t\tbvt.vty = vty;\n\t\tvty_out(vty, "BFD Peers:\\n");\n\t\tbfd_id_iterate(_display_bfd_counters_by_bfdname_iter, &bvt);\n\t\treturn;\n\t}\n\n\tjo = json_object_new_array();\n\tbvt.jo = jo;\n\tbfd_id_iterate(_display_bfd_counters_json_by_bfdname_iter, &bvt);\n\n\tvty_json(vty, jo);\n}\nstatic void _clear_bfd_counters_by_bfdname_iter(struct hash_bucket *hb, void *arg)\n{\n\tstruct bfd_vrf_tuple *bvt = arg;\n\tstruct bfd_session *bs = hb->data;\n\n\tif (!bvt)\n\t\treturn;\n\n\tif (bvt->vrfname) {\n\t\tif (!bs->key.vrfname[0] || !strmatch(bs->key.vrfname, bvt->vrfname))\n\t\t\treturn;\n\t}\n\n\tif (bvt->bfdname) {\n\t\tif (!bs->key.bfdname[0] || !strmatch(bs->key.bfdname, bvt->bfdname))\n\t\t\treturn;\n\t}\n\n\t_clear_peer_counter(bs);\n}\n\nstatic void _clear_bfd_counters_by_bfdname(const char *vrfname, const char *bfdname)\n{\n\tstruct bfd_vrf_tuple bvt = { 0 };\n\n\tbvt.vrfname = vrfname;\n\tbvt.bfdname = bfdname;\n\n\tbfd_id_iterate(_clear_bfd_counters_by_bfdname_iter, &bvt);\n}\n\nstatic void _clear_peer_counter(struct bfd_session *bs)\n{\n\t/* Clear only pkt stats, intention is not to loose system\n\t   events counters */\n\tbs->stats.rx_ctrl_pkt = 0;\n\tbs->stats.tx_ctrl_pkt = 0;\n\tbs->stats.rx_echo_pkt = 0;\n\tbs->stats.tx_echo_pkt = 0;\n}\n\nstatic void _display_peer_brief(struct vty *vty, struct bfd_session *bs)\n{\n\tchar addr_buf[INET6_ADDRSTRLEN];\n\n\tif (CHECK_FLAG(bs->flags, BFD_SESS_FLAG_MH)) {\n\t\tvty_out(vty, "%-10u", bs->discrs.my_discr);\n\t\tinet_ntop(bs->key.family, &bs->key.local, addr_buf, sizeof(addr_buf));\n\t\tvty_out(vty, " %-40s", addr_buf);\n\t\tinet_ntop(bs->key.family, &bs->key.peer, addr_buf, sizeof(addr_buf));\n\t\tvty_out(vty, " %-40s", addr_buf);\n\t\tvty_out(vty, "%-15s\\n", state_list[bs->ses_state].str);\n\t} else {\n\t\tvty_out(vty, "%-10u", bs->discrs.my_discr);\n\t\tvty_out(vty, " %-40s", satostr(&bs->local_address));\n\t\tinet_ntop(bs->key.family, &bs->key.peer, addr_buf, sizeof(addr_buf));\n\t\tvty_out(vty, " %-40s", addr_buf);\n\n\t\tvty_out(vty, "%-15s\\n", state_list[bs->ses_state].str);\n\t}\n}\n\nstatic void _display_peer_brief_iter(struct hash_bucket *hb, void *arg)\n{\n\tstruct bfd_vrf_tuple *bvt = arg;\n\tstruct vty *vty;\n\tstruct bfd_session *bs = hb->data;\n\n\tif (!bvt)\n\t\treturn;\n\tvty = bvt->vty;\n\n\tif (bvt->vrfname) {\n\t\tif (!bs->key.vrfname[0] ||\n\t\t\t!strmatch(bs->key.vrfname, bvt->vrfname))\n\t\treturn;\n\t}\n\n\t_display_peer_brief(vty, bs);\n}\n\nstatic void _display_peers_brief(struct vty *vty, const char *vrfname, bool use_json)\n{\n\tstruct json_object *jo;\n\tstruct bfd_vrf_tuple bvt = {0};\n\n\tbvt.vrfname = vrfname;\n\n\tif (!use_json) {\n\t\tbvt.vty = vty;\n\n\t\tvty_out(vty, "Session count: %lu\\n", bfd_get_session_count());\n\t\tvty_out(vty, "%-10s", "SessionId");\n\t\tvty_out(vty, " %-40s", "LocalAddress");\n\t\tvty_out(vty, " %-40s", "PeerAddress");\n\t\tvty_out(vty, "%-15s\\n", "Status");\n\n\t\tvty_out(vty, "%-10s", "=========");\n\t\tvty_out(vty, " %-40s", "============");\n\t\tvty_out(vty, " %-40s", "===========");\n\t\tvty_out(vty, "%-15s\\n", "======");\n\n\t\tbfd_id_iterate(_display_peer_brief_iter, &bvt);\n\t\treturn;\n\t}\n\n\tjo = json_object_new_array();\n\tbvt.jo = jo;\n\n\tbfd_id_iterate(_display_peer_json_iter, &bvt);\n\n\tvty_json(vty, jo);\n}\n\nstatic struct bfd_session *\n_find_peer_or_error(struct vty *vty, int argc, struct cmd_token **argv,\n\t\t    const char *label, const char *peer_str,\n\t\t    const char *local_str, const char *ifname,\n\t\t    const char *vrfname)\n{\n\tint idx;\n\tbool mhop;\n\tstruct bfd_session *bs = NULL;\n\tstruct bfd_peer_cfg bpc;\n\tstruct sockaddr_any psa, lsa, *lsap;\n\tchar errormsg[128];\n\tstruct vrf *vrf = NULL;\n\tchar *tmpName = NULL;\n\n\tif (peer_str) {\n\t\tstrtosa(peer_str, &psa);\n\t\tif (local_str) {\n\t\t\tstrtosa(local_str, &lsa);\n\t\t\tlsap = &lsa;\n\t\t} else\n\t\t\tlsap = NULL;\n\n\t\tidx = 0;\n\t\tmhop = argv_find(argv, argc, "multihop", &idx);\n\n\t\ttmpName = (char *)vrfname;\n\t\tif (vrfname) {\n\t\t\tvrf = vrf_lookup_by_name(vrfname);\n\t\t\tif (vrf == NULL) {\n\t\t\t\tvty_out(vty, "%% Vrf is not exist: %s\\n", vrfname);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttmpName = vrf->name;\n\t\t}\n\n\t\tif (bfd_configure_peer(&bpc, mhop, &psa, lsap, ifname, tmpName, errormsg,\n\t\t\t\t       sizeof(errormsg)) != 0) {\n\t\t\tvty_out(vty, "%% Invalid peer configuration: %s\\n",\n\t\t\t\terrormsg);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tbs = bs_peer_find(&bpc);\n\t} else {\n\t\tvty_out(vty, "%% Invalid arguments\\n");\n\t\treturn NULL;\n\t}\n\n\t/* Find peer data. */\n\tif (bs == NULL) {\n\t\tvty_out(vty, "%% Unable to find \'peer %s",\n\t\t\tlabel ? label : peer_str);\n\t\tif (ifname)\n\t\t\tvty_out(vty, " interface %s", ifname);\n\t\tif (local_str)\n\t\t\tvty_out(vty, " local-address %s", local_str);\n\t\tif (vrfname)\n\t\t\tvty_out(vty, " vrf %s", vrfname);\n\t\tvty_out(vty, "\'\\n");\n\n\t\treturn NULL;\n\t}\n\n\treturn bs;\n}\n\nvoid _display_rtt(uint32_t *min, uint32_t *avg, uint32_t *max,\n\t\t  struct bfd_session *bs)\n{\n#ifdef BFD_LINUX\n\tuint8_t i;\n\tuint32_t average = 0;\n\n\tif (bs->rtt_valid == 0)\n\t\treturn;\n\n\t*max = bs->rtt[0];\n\t*min = 1000;\n\t*avg = 0;\n\n\tfor (i = 0; i < bs->rtt_valid; i++) {\n\t\tif (bs->rtt[i] < *min)\n\t\t\t*min = bs->rtt[i];\n\t\tif (bs->rtt[i] > *max)\n\t\t\t*max = bs->rtt[i];\n\t\taverage += bs->rtt[i];\n\t}\n\t*avg = average / bs->rtt_valid;\n\n#endif\n}\n\n/*\n * Show commands.\n */\nDEFPY(bfd_show_by_bfdname, bfd_show_by_bfdname_cmd,\n      "show bfd [vrf NAME$vrf_name] bfd-name BFDNAME$bfdname [json]",\n      SHOW_STR\n      "Bidirection Forwarding Detection\\n"\n      VRF_CMD_HELP_STR\n\t  "Specify bfd session name\\n"\n\t  "bfd session name\\n"\n\t  JSON_STR)\n{\n\t_display_bfd_by_bfdname(vty, vrf_name, bfdname, use_json(argc, argv));\n\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(bfd_show_counters_by_bfdname, bfd_show_counters_by_bfdname_cmd,\n      "show bfd [vrf NAME$vrf_name] bfd-name BFDNAME$bfdname counters [json]",\n      SHOW_STR\n      "Bidirection Forwarding Detection\\n"\n      VRF_CMD_HELP_STR\n\t  "Specify bfd session name\\n"\n\t  "bfd session name\\n"\n      "Show BFD peer counters information\\n"\n      JSON_STR)\n{\n\t_display_bfd_counters_by_bfdname(vty, vrf_name, bfdname, use_json(argc, argv));\n\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(bfd_clear_counters_by_bfdname, bfd_clear_counters_by_bfdname_cmd,\n      "clear bfd [vrf NAME$vrfname] bfd-name BFDNAME$bfdname counters",\n      CLEAR_STR\n      "Bidirection Forwarding Detection\\n"\n      VRF_CMD_HELP_STR\n\t  "Specify bfd session name\\n"\n\t  "bfd session name\\n"\n\t  "clear BFD peer counters information\\n")\n{\n\t_clear_bfd_counters_by_bfdname(vrfname, bfdname);\n\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(bfd_show_peers, bfd_show_peers_cmd, "show bfd [vrf NAME] peers [json]",\n      SHOW_STR\n      "Bidirection Forwarding Detection\\n"\n       VRF_CMD_HELP_STR\n      "BFD peers status\\n" JSON_STR)\n{\n\tchar *vrf_name = NULL;\n\tint idx_vrf = 0;\n\n\tif (argv_find(argv, argc, "vrf", &idx_vrf))\n\t\tvrf_name = argv[idx_vrf + 1]->arg;\n\n\t_display_all_peers(vty, vrf_name, use_json(argc, argv));\n\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(bfd_show_peer, bfd_show_peer_cmd,\n      "show bfd [vrf NAME$vrf_name] peer <WORD$label|<A.B.C.D|X:X::X:X>$peer [{multihop|local-address <A.B.C.D|X:X::X:X>$local|interface IFNAME$ifname}]> [json]",\n      SHOW_STR\n      "Bidirection Forwarding Detection\\n"\n      VRF_CMD_HELP_STR\n      "BFD peers status\\n"\n      "Peer label\\n" PEER_IPV4_STR PEER_IPV6_STR MHOP_STR LOCAL_STR\n\t      LOCAL_IPV4_STR LOCAL_IPV6_STR INTERFACE_STR LOCAL_INTF_STR JSON_STR)\n{\n\tstruct bfd_session *bs;\n\n\t/* Look up the BFD peer. */\n\tbs = _find_peer_or_error(vty, argc, argv, label, peer_str, local_str,\n\t\t\t\t ifname, vrf_name);\n\tif (bs == NULL)\n\t\treturn CMD_WARNING_CONFIG_FAILED;\n\n\tif (use_json(argc, argv)) {\n\t\t_display_peer_json(vty, bs);\n\t} else {\n\t\tvty_out(vty, "BFD Peer:\\n");\n\t\t_display_peer(vty, bs);\n\t}\n\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(bfd_show_peer_counters, bfd_show_peer_counters_cmd,\n      "show bfd [vrf NAME$vrf_name] peer <WORD$label|<A.B.C.D|X:X::X:X>$peer [{multihop|local-address <A.B.C.D|X:X::X:X>$local|interface IFNAME$ifname}]> counters [json]",\n      SHOW_STR\n      "Bidirection Forwarding Detection\\n"\n      VRF_CMD_HELP_STR\n      "BFD peers status\\n"\n      "Peer label\\n"\n      PEER_IPV4_STR\n      PEER_IPV6_STR\n      MHOP_STR\n      LOCAL_STR\n      LOCAL_IPV4_STR\n      LOCAL_IPV6_STR\n      INTERFACE_STR\n      LOCAL_INTF_STR\n      "Show BFD peer counters information\\n"\n      JSON_STR)\n{\n\tstruct bfd_session *bs;\n\n\t/* Look up the BFD peer. */\n\tbs = _find_peer_or_error(vty, argc, argv, label, peer_str, local_str,\n\t\t\t\t ifname, vrf_name);\n\tif (bs == NULL)\n\t\treturn CMD_WARNING_CONFIG_FAILED;\n\n\tif (use_json(argc, argv))\n\t\t_display_peer_counters_json(vty, bs);\n\telse\n\t\t_display_peer_counter(vty, bs);\n\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(bfd_show_peers_counters, bfd_show_peers_counters_cmd,\n      "show bfd [vrf NAME] peers counters [json]",\n      SHOW_STR\n      "Bidirection Forwarding Detection\\n"\n      VRF_CMD_HELP_STR\n      "BFD peers status\\n"\n      "Show BFD peer counters information\\n"\n      JSON_STR)\n{\n\tchar *vrf_name = NULL;\n\tint idx_vrf = 0;\n\n\tif (argv_find(argv, argc, "vrf", &idx_vrf))\n\t\tvrf_name = argv[idx_vrf + 1]->arg;\n\n\t_display_peers_counter(vty, vrf_name, use_json(argc, argv));\n\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(bfd_clear_peer_counters, bfd_clear_peer_counters_cmd,\n      "clear bfd [vrf <NAME$vrfname>] peer <WORD$label|<A.B.C.D|X:X::X:X>$peer [{multihop|local-address <A.B.C.D|X:X::X:X>$local|interface IFNAME$ifname}]> counters",\n      SHOW_STR\n      "Bidirection Forwarding Detection\\n"\n      VRF_CMD_HELP_STR\n      "BFD peers status\\n"\n      "Peer label\\n"\n      PEER_IPV4_STR\n      PEER_IPV6_STR\n      MHOP_STR\n      LOCAL_STR\n      LOCAL_IPV4_STR\n      LOCAL_IPV6_STR\n      INTERFACE_STR\n      LOCAL_INTF_STR\n      "clear BFD peer counters information\\n")\n{\n\tstruct bfd_session *bs;\n\n\t/* Look up the BFD peer. */\n\tbs = _find_peer_or_error(vty, argc, argv, label, peer_str, local_str,\n\t\t\t\tifname, vrfname);\n\tif (bs == NULL)\n\t\treturn CMD_WARNING_CONFIG_FAILED;\n\n\t_clear_peer_counter(bs);\n\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(bfd_show_peers_brief, bfd_show_peers_brief_cmd,\n      "show bfd [vrf <NAME$vrfname>] peers brief [json]",\n      SHOW_STR\n      "Bidirection Forwarding Detection\\n"\n      VRF_CMD_HELP_STR\n      "BFD peers status\\n"\n      "Show BFD peer information in tabular form\\n"\n      JSON_STR)\n{\n\tchar *vrf_name = NULL;\n\tint idx_vrf = 0;\n\n\tif (argv_find(argv, argc, "vrf", &idx_vrf))\n\t\tvrf_name = argv[idx_vrf + 1]->arg;\n\n\t_display_peers_brief(vty, vrf_name, use_json(argc, argv));\n\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(show_bfd_distributed, show_bfd_distributed_cmd,\n      "show bfd distributed",\n      SHOW_STR\n      "Bidirection Forwarding Detection\\n"\n      "Show BFD data plane (distributed BFD) statistics\\n")\n{\n\tbfd_dplane_show_counters(vty);\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(\n\tbfd_debug_distributed, bfd_debug_distributed_cmd,\n\t"[no] debug bfd distributed",\n\tNO_STR\n\tDEBUG_STR\n\t"Bidirection Forwarding Detection\\n"\n\t"BFD data plane (distributed BFD) debugging\\n")\n{\n\tbglobal.debug_dplane = !no;\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(\n\tbfd_debug_peer, bfd_debug_peer_cmd,\n\t"[no] debug bfd peer",\n\tNO_STR\n\tDEBUG_STR\n\t"Bidirection Forwarding Detection\\n"\n\t"Peer events debugging\\n")\n{\n\tbglobal.debug_peer_event = !no;\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(\n\tbfd_debug_zebra, bfd_debug_zebra_cmd,\n\t"[no] debug bfd zebra",\n\tNO_STR\n\tDEBUG_STR\n\t"Bidirection Forwarding Detection\\n"\n\t"Zebra events debugging\\n")\n{\n\tbglobal.debug_zebra = !no;\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(\n\tbfd_debug_network, bfd_debug_network_cmd,\n\t"[no] debug bfd network",\n\tNO_STR\n\tDEBUG_STR\n\t"Bidirection Forwarding Detection\\n"\n\t"Network layer debugging\\n")\n{\n\tbglobal.debug_network = !no;\n\treturn CMD_SUCCESS;\n}\n\n/*\n * Function definitions.\n */\n\n/*\n * Configuration rules:\n *\n * Single hop:\n * peer + (interface name)\n *\n * Multi hop:\n * peer + local + (optional vrf)\n *\n * Anything else is misconfiguration.\n */\nstatic int bfd_configure_peer(struct bfd_peer_cfg *bpc, bool mhop,\n\t\t\t      const struct sockaddr_any *peer,\n\t\t\t      const struct sockaddr_any *local,\n\t\t\t      const char *ifname, const char *vrfname,\n\t\t\t      char *ebuf, size_t ebuflen)\n{\n\tmemset(bpc, 0, sizeof(*bpc));\n\n\t/* Defaults */\n\tbpc->bpc_shutdown = false;\n\tbpc->bpc_log_session_changes = false;\n\tbpc->bpc_detectmultiplier = BPC_DEF_DETECTMULTIPLIER;\n\tbpc->bpc_recvinterval = BPC_DEF_RECEIVEINTERVAL;\n\tbpc->bpc_txinterval = BPC_DEF_TRANSMITINTERVAL;\n\tbpc->bpc_echorecvinterval = BPC_DEF_ECHORECEIVEINTERVAL;\n\tbpc->bpc_echotxinterval = BPC_DEF_ECHOTRANSMITINTERVAL;\n\n\t/* Safety check: when no error buf is provided len must be zero. */\n\tif (ebuf == NULL)\n\t\tebuflen = 0;\n\n\t/* Peer is always mandatory. */\n\tif (peer == NULL) {\n\t\tsnprintf(ebuf, ebuflen, "peer must not be empty");\n\t\treturn -1;\n\t}\n\n\t/* Validate address families. */\n\tif (peer->sa_sin.sin_family == AF_INET) {\n\t\tif (local && local->sa_sin.sin_family != AF_INET) {\n\t\t\tsnprintf(ebuf, ebuflen,\n\t\t\t\t "local is IPv6, but peer is IPv4");\n\t\t\treturn -1;\n\t\t}\n\n\t\tbpc->bpc_ipv4 = true;\n\t} else if (peer->sa_sin.sin_family == AF_INET6) {\n\t\tif (local && local->sa_sin.sin_family != AF_INET6) {\n\t\t\tsnprintf(ebuf, ebuflen,\n\t\t\t\t "local is IPv4, but peer is IPv6");\n\t\t\treturn -1;\n\t\t}\n\n\t\tbpc->bpc_ipv4 = false;\n\t} else {\n\t\tsnprintf(ebuf, ebuflen, "invalid peer address family");\n\t\treturn -1;\n\t}\n\n\t/* Copy local and/or peer addresses. */\n\tif (local)\n\t\tbpc->bpc_local = *local;\n\n\tbpc->bpc_peer = *peer;\n\tbpc->bpc_mhop = mhop;\n\n\t/* Handle interface specification configuration. */\n\tif (ifname) {\n\t\tbpc->bpc_has_localif = true;\n\t\tif (strlcpy(bpc->bpc_localif, ifname, sizeof(bpc->bpc_localif))\n\t\t    > sizeof(bpc->bpc_localif)) {\n\t\t\tsnprintf(ebuf, ebuflen, "interface name too long");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Handle VRF configuration. */\n\tif (vrfname) {\n\t\tbpc->bpc_has_vrfname = true;\n\t\tif (strlcpy(bpc->bpc_vrfname, vrfname, sizeof(bpc->bpc_vrfname))\n\t\t    > sizeof(bpc->bpc_vrfname)) {\n\t\t\tsnprintf(ebuf, ebuflen, "vrf name too long");\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tbpc->bpc_has_vrfname = true;\n\t\tstrlcpy(bpc->bpc_vrfname, VRF_DEFAULT_NAME, sizeof(bpc->bpc_vrfname));\n\t}\n\n\treturn 0;\n}\n\nDEFUN_NOSH(show_debugging_bfd,\n\t   show_debugging_bfd_cmd,\n\t   "show debugging [bfd]",\n\t   SHOW_STR\n\t   DEBUG_STR\n\t   "BFD daemon\\n")\n{\n\tvty_out(vty, "BFD debugging status:\\n");\n\tif (bglobal.debug_dplane)\n\t\tvty_out(vty, "  Distributed BFD debugging is on.\\n");\n\tif (bglobal.debug_peer_event)\n\t\tvty_out(vty, "  Peer events debugging is on.\\n");\n\tif (bglobal.debug_zebra)\n\t\tvty_out(vty, "  Zebra events debugging is on.\\n");\n\tif (bglobal.debug_network)\n\t\tvty_out(vty, "  Network layer debugging is on.\\n");\n\n\tcmd_show_lib_debugs(vty);\n\n\treturn CMD_SUCCESS;\n}\n\nstatic int bfdd_write_config(struct vty *vty);\nstruct cmd_node bfd_node = {\n\t.name = "bfd",\n\t.node = BFD_NODE,\n\t.parent_node = CONFIG_NODE,\n\t.prompt = "%s(config-bfd)# ",\n\t.config_write = bfdd_write_config,\n};\n\nstruct cmd_node bfd_peer_node = {\n\t.name = "bfd peer",\n\t.node = BFD_PEER_NODE,\n\t.parent_node = BFD_NODE,\n\t.prompt = "%s(config-bfd-peer)# ",\n};\n\nstatic void _sbfd_reflector_write_config(struct hash_bucket *hb, void *arg)\n{\n\tstruct sbfd_reflector *sr = hb->data;\n\tchar buf[INET6_ADDRSTRLEN];\n\tstruct vty *vty;\n\n\tvty = (struct vty *)arg;\n\tinet_ntop(AF_INET6, &sr->local, buf, sizeof(buf));\n\tvty_out(vty, "  sbfd reflector source-address %s discriminator %u\\n", buf, sr->discr);\n}\n\nstatic void sbfd_reflector_write_config(struct vty *vty)\n{\n\tsbfd_discr_iterate(_sbfd_reflector_write_config, vty);\n}\n\nstatic int bfdd_write_config(struct vty *vty)\n{\n\tstruct lyd_node *dnode;\n\tint written = 0;\n\n\tif (bglobal.debug_dplane) {\n\t\tvty_out(vty, "debug bfd distributed\\n");\n\t\twritten = 1;\n\t}\n\n\tif (bglobal.debug_peer_event) {\n\t\tvty_out(vty, "debug bfd peer\\n");\n\t\twritten = 1;\n\t}\n\n\tif (bglobal.debug_zebra) {\n\t\tvty_out(vty, "debug bfd zebra\\n");\n\t\twritten = 1;\n\t}\n\n\tif (bglobal.debug_network) {\n\t\tvty_out(vty, "debug bfd network\\n");\n\t\twritten = 1;\n\t}\n\n\tdnode = yang_dnode_get(running_config->dnode, "/frr-bfdd:bfdd");\n\tif (dnode) {\n\t\tnb_cli_show_dnode_cmds(vty, dnode, false);\n\t\twritten = 1;\n\t}\n\n\t/*sbfd config*/\n\tsbfd_reflector_write_config(vty);\n\n\treturn written;\n}\n\n/*\n * Micro-BFD LAG show commands (RFC 7130)\n */\n#include "bfd_lag.h"\n\nDEFPY(show_bfd_lag, show_bfd_lag_cmd,\n      "show bfd lag [LAGNAME$lagname] [json]",\n      SHOW_STR\n      "Bidirection Forwarding Detection\\n"\n      "Show Micro-BFD LAG sessions\\n"\n      "Specific LAG name\\n"\n      JSON_STR)\n{\n\tstruct json_object *json_out = NULL;\n\n\tif (use_json(argc, argv))\n\t\tjson_out = json_object_new_object();\n\n\tbfd_lag_show(vty, lagname, json_out);\n\n\tif (json_out) {\n\t\tvty_json(vty, json_out);\n\t}\n\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(show_bfd_lag_members, show_bfd_lag_members_cmd,\n      "show bfd lag LAGNAME$lagname members [json]",\n      SHOW_STR\n      "Bidirection Forwarding Detection\\n"\n      "Show Micro-BFD LAG sessions\\n"\n      "LAG name\\n"\n      "Show member links status\\n"\n      JSON_STR)\n{\n\tstruct bfd_lag *lag;\n\tstruct json_object *json_out = NULL;\n\n\tlag = bfd_lag_find(lagname, NULL);\n\tif (lag == NULL) {\n\t\tvty_out(vty, "%% Cannot find LAG %s\\n", lagname);\n\t\treturn CMD_WARNING;\n\t}\n\n\tif (use_json(argc, argv))\n\t\tjson_out = json_object_new_object();\n\n\tbfd_lag_show_members(vty, lag, json_out);\n\n\tif (json_out) {\n\t\tvty_json(vty, json_out);\n\t}\n\n\treturn CMD_SUCCESS;\n}\n\nvoid bfdd_vty_init(void)\n{\n\tinstall_element(ENABLE_NODE, &bfd_show_peers_counters_cmd);\n\tinstall_element(ENABLE_NODE, &bfd_show_peer_counters_cmd);\n\tinstall_element(ENABLE_NODE, &bfd_clear_peer_counters_cmd);\n\tinstall_element(ENABLE_NODE, &bfd_show_peers_cmd);\n\tinstall_element(ENABLE_NODE, &bfd_show_by_bfdname_cmd);\n\tinstall_element(ENABLE_NODE, &bfd_show_counters_by_bfdname_cmd);\n\tinstall_element(ENABLE_NODE, &bfd_clear_counters_by_bfdname_cmd);\n\tinstall_element(ENABLE_NODE, &bfd_show_peer_cmd);\n\tinstall_element(ENABLE_NODE, &bfd_show_peers_brief_cmd);\n\tinstall_element(ENABLE_NODE, &show_bfd_distributed_cmd);\n\tinstall_element(ENABLE_NODE, &show_debugging_bfd_cmd);\n\n\t/* Micro-BFD LAG show commands (RFC 7130) */\n\tinstall_element(ENABLE_NODE, &show_bfd_lag_cmd);\n\tinstall_element(ENABLE_NODE, &show_bfd_lag_members_cmd);\n\tinstall_element(VIEW_NODE, &show_bfd_lag_cmd);\n\tinstall_element(VIEW_NODE, &show_bfd_lag_members_cmd);\n\n\tinstall_element(ENABLE_NODE, &bfd_debug_distributed_cmd);\n\tinstall_element(ENABLE_NODE, &bfd_debug_peer_cmd);\n\tinstall_element(ENABLE_NODE, &bfd_debug_zebra_cmd);\n\tinstall_element(ENABLE_NODE, &bfd_debug_network_cmd);\n\n\tinstall_element(CONFIG_NODE, &bfd_debug_distributed_cmd);\n\tinstall_element(CONFIG_NODE, &bfd_debug_peer_cmd);\n\tinstall_element(CONFIG_NODE, &bfd_debug_zebra_cmd);\n\tinstall_element(CONFIG_NODE, &bfd_debug_network_cmd);\n\n\t/* Install BFD node and commands. */\n\tinstall_node(&bfd_node);\n\tinstall_default(BFD_NODE);\n\n\t/* Install BFD peer node. */\n\tinstall_node(&bfd_peer_node);\n\tinstall_default(BFD_PEER_NODE);\n\n\tbfdd_cli_init();\n}\n' : show bfd lag command should be defined

  FAIL: test_show_lag_members_command_defined (__main__.TestMicroBFDCLI)
        File "/home/ubuntu/sonic/frr/tests/bfdd/test_bfd_lag.py", line 334, in test_show_lag_members_command_defined
        self.assertIn("bfd_show_lag_members", self.vty_content,
        AssertionError: 'bfd_show_lag_members' not found in '// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * BFD daemon code\n * Copyright (C) 2018 Network Device Education Foundation, Inc. ("NetDEF")\n */\n\n#include <zebra.h>\n\n#include "lib/command.h"\n#include "lib/json.h"\n#include "lib/log.h"\n#include "lib/northbound_cli.h"\n#include "lib/vty.h"\n\n#include "bfd.h"\n#include "bfd_trace.h"\n\n#include "bfdd/bfdd_vty_clippy.c"\n\n/*\n * Commands help string definitions.\n */\n#define PEER_IPV4_STR "IPv4 peer address\\n"\n#define PEER_IPV6_STR "IPv6 peer address\\n"\n#define MHOP_STR "Configure multihop\\n"\n#define LOCAL_STR "Configure local address\\n"\n#define LOCAL_IPV4_STR "IPv4 local address\\n"\n#define LOCAL_IPV6_STR "IPv6 local address\\n"\n#define LOCAL_INTF_STR "Configure local interface name to use\\n"\n\n/*\n * Prototypes\n */\nstatic int bfd_configure_peer(struct bfd_peer_cfg *bpc, bool mhop,\n\t\t\t      const struct sockaddr_any *peer,\n\t\t\t      const struct sockaddr_any *local,\n\t\t\t      const char *ifname, const char *vrfname,\n\t\t\t      char *ebuf, size_t ebuflen);\n\nstatic void _display_peer_header(struct vty *vty, struct bfd_session *bs);\nstatic struct json_object *__display_peer_json(struct bfd_session *bs);\nstatic struct json_object *_peer_json_header(struct bfd_session *bs);\nstatic void _display_peer_json(struct vty *vty, struct bfd_session *bs);\nstatic void _display_peer(struct vty *vty, struct bfd_session *bs);\nstatic void _display_all_peers(struct vty *vty, char *vrfname, bool use_json);\nstatic void _display_peer_iter(struct hash_bucket *hb, void *arg);\nstatic void _display_peer_json_iter(struct hash_bucket *hb, void *arg);\nstatic void _display_peer_counter(struct vty *vty, struct bfd_session *bs);\nstatic struct json_object *__display_peer_counters_json(struct bfd_session *bs);\nstatic void _display_peer_counters_json(struct vty *vty, struct bfd_session *bs);\nstatic void _display_peer_counter_iter(struct hash_bucket *hb, void *arg);\nstatic void _display_peer_counter_json_iter(struct hash_bucket *hb, void *arg);\nstatic void _display_peers_counter(struct vty *vty, char *vrfname, bool use_json);\nstatic void _display_rtt(uint32_t *min, uint32_t *avg, uint32_t *max,\n\t\t\t struct bfd_session *bs);\n\nstatic struct bfd_session *\n_find_peer_or_error(struct vty *vty, int argc, struct cmd_token **argv,\n\t\t    const char *label, const char *peer_str,\n\t\t    const char *local_str, const char *ifname,\n\t\t    const char *vrfname);\nstatic void _display_bfd_by_bfdname_json_iter(struct hash_bucket *hb, void *arg);\nstatic void _display_bfd_by_bfdname_iter(struct hash_bucket *hb, void *arg);\nstatic void _display_bfd_by_bfdname(struct vty *vty, const char *vrfname, const char *bfdname,\n\t\t\t\t    bool use_json);\nstatic void _display_bfd_counters_by_bfdname_iter(struct hash_bucket *hb, void *arg);\nstatic void _display_bfd_counters_json_by_bfdname_iter(struct hash_bucket *hb, void *arg);\nstatic void _display_bfd_counters_by_bfdname(struct vty *vty, const char *vrfname,\n\t\t\t\t\t     const char *bfdname, bool use_json);\nstatic void _clear_bfd_counters_by_bfdname(const char *vrfname, const char *bfdname);\nstatic void _clear_peer_counter(struct bfd_session *bs);\n\nstatic const char *bfd_mode_type_to_string(enum bfd_mode_type mode)\n{\n\tswitch (mode) {\n\tcase BFD_MODE_TYPE_BFD:\n\t\treturn "bfd";\n\tcase BFD_MODE_TYPE_SBFD_ECHO:\n\t\treturn "sbfd-echo";\n\tcase BFD_MODE_TYPE_SBFD_INIT:\n\t\treturn "sbfd-init";\n\tdefault:\n\t\treturn "Unknown";\n\t}\n}\n\nstatic char *sbfd_sidlist_to_string(struct in6_addr *sidlist, uint8_t segnum)\n{\n\tstatic char buf[INET6_ADDRSTRLEN * SRV6_MAX_SEGS];\n\tint pos = 0;\n\tuint8_t i = 0;\n\tchar addr_buf[INET6_ADDRSTRLEN];\n\n\tmemset(buf, 0, 256);\n\n\tpos = snprintf(buf, sizeof(buf), "%s",\n\t\t       inet_ntop(AF_INET6, &sidlist[0], addr_buf, sizeof(addr_buf)));\n\n\tfor (i = 1; i < segnum; i++)\n\t\tpos += snprintf(buf + pos, sizeof(buf) - pos, " %s",\n\t\t\t\tinet_ntop(AF_INET6, &sidlist[i], addr_buf, sizeof(addr_buf)));\n\n\treturn buf;\n}\n\n/*\n * Show commands helper functions\n */\nstatic void _display_peer_header(struct vty *vty, struct bfd_session *bs)\n{\n\tchar addr_buf[INET6_ADDRSTRLEN];\n\n\tvty_out(vty, "\\tpeer %s",\n\t\tinet_ntop(bs->key.family, &bs->key.peer, addr_buf,\n\t\t\t  sizeof(addr_buf)));\n\n\tif (bs->bfd_mode == BFD_MODE_TYPE_SBFD_ECHO || bs->bfd_mode == BFD_MODE_TYPE_SBFD_INIT)\n\t\tvty_out(vty, " bfd-mode %s", bfd_mode_type_to_string(bs->bfd_mode));\n\n\tif (bs->bfd_name[0])\n\t\tvty_out(vty, " bfd-name %s", bs->bfd_name);\n\n\tif (CHECK_FLAG(bs->flags, BFD_SESS_FLAG_MH))\n\t\tvty_out(vty, " multihop");\n\n\tif (memcmp(&bs->key.local, &zero_addr, sizeof(bs->key.local)))\n\t\tvty_out(vty, " local-address %s",\n\t\t\tinet_ntop(bs->key.family, &bs->key.local, addr_buf,\n\t\t\t\t  sizeof(addr_buf)));\n\n\tif (bs->key.vrfname[0])\n\t\tvty_out(vty, " vrf %s", bs->key.vrfname);\n\tif (bs->key.ifname[0])\n\t\tvty_out(vty, " interface %s", bs->key.ifname);\n\n\tif (bs->bfd_mode == BFD_MODE_TYPE_SBFD_ECHO || bs->bfd_mode == BFD_MODE_TYPE_SBFD_INIT) {\n\t\tif (bs->bfd_mode == BFD_MODE_TYPE_SBFD_INIT)\n\t\t\tvty_out(vty, " remote-discr %u", bs->discrs.remote_discr);\n\n\t\tif (bs->bfd_name[0] && bs->segnum) {\n\t\t\tvty_out(vty, " srv6-source-ipv6 %s",\n\t\t\t\tinet_ntop(AF_INET6, &bs->out_sip6, addr_buf, sizeof(addr_buf)));\n\n\t\t\tvty_out(vty, " srv6-encap-data %s",\n\t\t\t\tsbfd_sidlist_to_string(bs->seg_list, bs->segnum));\n\t\t}\n\t}\n\n\tvty_out(vty, "\\n");\n}\n\nstatic void _display_peer(struct vty *vty, struct bfd_session *bs)\n{\n\tchar buf[256];\n\ttime_t now;\n\tuint32_t min = 0;\n\tuint32_t avg = 0;\n\tuint32_t max = 0;\n\n\t_display_peer_header(vty, bs);\n\n\tvty_out(vty, "\\t\\tID: %u\\n", bs->discrs.my_discr);\n\tvty_out(vty, "\\t\\tRemote ID: %u\\n", bs->discrs.remote_discr);\n\tif (CHECK_FLAG(bs->flags, BFD_SESS_FLAG_PASSIVE))\n\t\tvty_out(vty, "\\t\\tPassive mode\\n");\n\telse\n\t\tvty_out(vty, "\\t\\tActive mode\\n");\n\tif (CHECK_FLAG(bs->flags, BFD_SESS_FLAG_LOG_SESSION_CHANGES))\n\t\tvty_out(vty, "\\t\\tLog session changes\\n");\n\tif (CHECK_FLAG(bs->flags, BFD_SESS_FLAG_MH))\n\t\tvty_out(vty, "\\t\\tMinimum TTL: %d\\n", bs->mh_ttl);\n\tvty_out(vty, "\\t\\tStatus: ");\n\tswitch (bs->ses_state) {\n\tcase PTM_BFD_ADM_DOWN:\n\t\tvty_out(vty, "shutdown\\n");\n\t\tbreak;\n\tcase PTM_BFD_DOWN:\n\t\tvty_out(vty, "down\\n");\n\n\t\tnow = monotime(NULL);\n\t\tinteger2timestr(now - bs->downtime.tv_sec, buf, sizeof(buf));\n\t\tvty_out(vty, "\\t\\tDowntime: %s\\n", buf);\n\t\tbreak;\n\tcase PTM_BFD_INIT:\n\t\tvty_out(vty, "init\\n");\n\t\tbreak;\n\tcase PTM_BFD_UP:\n\t\tvty_out(vty, "up\\n");\n\n\t\tnow = monotime(NULL);\n\t\tinteger2timestr(now - bs->uptime.tv_sec, buf, sizeof(buf));\n\t\tvty_out(vty, "\\t\\tUptime: %s\\n", buf);\n\t\tbreak;\n\n\tdefault:\n\t\tvty_out(vty, "unknown\\n");\n\t\tbreak;\n\t}\n\n\tvty_out(vty, "\\t\\tDiagnostics: %s\\n", diag2str(bs->local_diag));\n\tvty_out(vty, "\\t\\tRemote diagnostics: %s\\n", diag2str(bs->remote_diag));\n\tif (bs->bfd_mode == BFD_MODE_TYPE_SBFD_INIT) {\n\t\tvty_out(vty, "\\t\\tPeer Type: sbfd initiator\\n");\n\t} else if (bs->bfd_mode == BFD_MODE_TYPE_SBFD_ECHO) {\n\t\tvty_out(vty, "\\t\\tPeer Type: echo\\n");\n\t} else {\n\t\tvty_out(vty, "\\t\\tPeer Type: %s\\n",\n\t\t\tCHECK_FLAG(bs->flags, BFD_SESS_FLAG_CONFIG) ? "configured" : "dynamic");\n\t\t_display_rtt(&min, &avg, &max, bs);\n\t\tvty_out(vty, "\\t\\tRTT min/avg/max: %u/%u/%u usec\\n", min, avg, max);\n\t}\n\n\tvty_out(vty, "\\t\\tLocal timers:\\n");\n\tvty_out(vty, "\\t\\t\\tDetect-multiplier: %u\\n",\n\t\tbs->detect_mult);\n\tvty_out(vty, "\\t\\t\\tReceive interval: %ums\\n",\n\t\tbs->timers.required_min_rx / 1000);\n\tvty_out(vty, "\\t\\t\\tTransmission interval: %ums\\n",\n\t\tbs->timers.desired_min_tx / 1000);\n\tif (bs->xmt_TO_actual > 0)\n\t\tvty_out(vty, "\\t\\t\\tTransmission interval (actual with jitter): %" PRIu64 "ms\\n",\n\t\t\tbs->xmt_TO_actual / 1000);\n\tif (bs->detect_TO > 0)\n\t\tvty_out(vty, "\\t\\t\\tDetection timeout: %" PRIu64 "ms\\n",\n\t\t\tbs->detect_TO / 1000);\n\tif (bs->timers.required_min_echo_rx != 0)\n\t\tvty_out(vty, "\\t\\t\\tEcho receive interval: %ums\\n",\n\t\t\tbs->timers.required_min_echo_rx / 1000);\n\telse\n\t\tvty_out(vty, "\\t\\t\\tEcho receive interval: disabled\\n");\n\tif (CHECK_FLAG(bs->flags, BFD_SESS_FLAG_ECHO) || bs->bfd_mode == BFD_MODE_TYPE_SBFD_ECHO) {\n\t\tvty_out(vty, "\\t\\t\\tEcho transmission interval: %ums\\n",\n\t\t\tbs->timers.desired_min_echo_tx / 1000);\n\t\tif (bs->echo_xmt_TO_actual > 0)\n\t\t\tvty_out(vty,\n\t\t\t\t"\\t\\t\\tEcho transmission interval (actual with jitter): %" PRIu64\n\t\t\t\t"ms\\n",\n\t\t\t\tbs->echo_xmt_TO_actual / 1000);\n\t} else\n\t\tvty_out(vty, "\\t\\t\\tEcho transmission interval: disabled\\n");\n\n\n\tif (bs->bfd_mode == BFD_MODE_TYPE_SBFD_INIT || bs->bfd_mode == BFD_MODE_TYPE_SBFD_ECHO) {\n\t\tvty_out(vty, "\\t\\tRemote timers:\\n");\n\t\tvty_out(vty, "\\t\\t\\tDetect-multiplier: -\\n");\n\t\tvty_out(vty, "\\t\\t\\tReceive interval: -\\n");\n\t\tvty_out(vty, "\\t\\t\\tTransmission interval: -\\n");\n\t\tvty_out(vty, "\\t\\t\\tEcho receive interval: -\\n");\n\t} else {\n\t\tvty_out(vty, "\\t\\tRemote timers:\\n");\n\t\tvty_out(vty, "\\t\\t\\tDetect-multiplier: %u\\n", bs->remote_detect_mult);\n\t\tvty_out(vty, "\\t\\t\\tReceive interval: %ums\\n",\n\t\t\tbs->remote_timers.required_min_rx / 1000);\n\t\tvty_out(vty, "\\t\\t\\tTransmission interval: %ums\\n",\n\t\t\tbs->remote_timers.desired_min_tx / 1000);\n\t\tif (bs->remote_timers.required_min_echo != 0)\n\t\t\tvty_out(vty, "\\t\\t\\tEcho receive interval: %ums\\n",\n\t\t\t\tbs->remote_timers.required_min_echo / 1000);\n\t\telse\n\t\t\tvty_out(vty, "\\t\\t\\tEcho receive interval: disabled\\n");\n\t}\n\n\tvty_out(vty, "\\n");\n}\n\nstatic struct json_object *_peer_json_header(struct bfd_session *bs)\n{\n\tstruct json_object *jo = json_object_new_object();\n\tchar addr_buf[INET6_ADDRSTRLEN];\n\n\tif (bs->key.mhop)\n\t\tjson_object_boolean_true_add(jo, "multihop");\n\telse\n\t\tjson_object_boolean_false_add(jo, "multihop");\n\n\tjson_object_string_add(jo, "peer",\n\t\t\t       inet_ntop(bs->key.family, &bs->key.peer,\n\t\t\t\t\t addr_buf, sizeof(addr_buf)));\n\tif (memcmp(&bs->key.local, &zero_addr, sizeof(bs->key.local)))\n\t\tjson_object_string_add(jo, "local",\n\t\t\t\t       inet_ntop(bs->key.family, &bs->key.local,\n\t\t\t\t\t\t addr_buf, sizeof(addr_buf)));\n\n\tif (bs->key.vrfname[0])\n\t\tjson_object_string_add(jo, "vrf", bs->key.vrfname);\n\tif (bs->key.ifname[0])\n\t\tjson_object_string_add(jo, "interface", bs->key.ifname);\n\n\treturn jo;\n}\n\nstatic struct json_object *__display_peer_json(struct bfd_session *bs)\n{\n\tstruct json_object *jo = _peer_json_header(bs);\n\tuint32_t min = 0;\n\tuint32_t avg = 0;\n\tuint32_t max = 0;\n\n\tif (bs->key.ifname[0])\n\t\tjson_object_string_add(jo, "interface", bs->key.ifname);\n\tjson_object_int_add(jo, "id", bs->discrs.my_discr);\n\tjson_object_int_add(jo, "remote-id", bs->discrs.remote_discr);\n\tjson_object_boolean_add(jo, "passive-mode",\n\t\t\t\tCHECK_FLAG(bs->flags, BFD_SESS_FLAG_PASSIVE));\n\tjson_object_boolean_add(jo, "log-session-changes",\n\t\t\t\tCHECK_FLAG(bs->flags, BFD_SESS_FLAG_LOG_SESSION_CHANGES));\n\tif (CHECK_FLAG(bs->flags, BFD_SESS_FLAG_MH))\n\t\tjson_object_int_add(jo, "minimum-ttl", bs->mh_ttl);\n\n\tif (bs->bfd_mode != BFD_MODE_TYPE_BFD)\n\t\tjson_object_string_add(jo, "bfd-name", bs->bfd_name);\n\n\tswitch (bs->ses_state) {\n\tcase PTM_BFD_ADM_DOWN:\n\t\tjson_object_string_add(jo, "status", "shutdown");\n\t\tbreak;\n\tcase PTM_BFD_DOWN:\n\t\tjson_object_string_add(jo, "status", "down");\n\t\tjson_object_int_add(jo, "downtime",\n\t\t\t\t    monotime(NULL) - bs->downtime.tv_sec);\n\t\tbreak;\n\tcase PTM_BFD_INIT:\n\t\tjson_object_string_add(jo, "status", "init");\n\t\tbreak;\n\tcase PTM_BFD_UP:\n\t\tjson_object_string_add(jo, "status", "up");\n\t\tjson_object_int_add(jo, "uptime",\n\t\t\t\t    monotime(NULL) - bs->uptime.tv_sec);\n\t\tbreak;\n\n\tdefault:\n\t\tjson_object_string_add(jo, "status", "unknown");\n\t\tbreak;\n\t}\n\n\tjson_object_string_add(jo, "diagnostic", diag2str(bs->local_diag));\n\tjson_object_string_add(jo, "remote-diagnostic",\n\t\t\t       diag2str(bs->remote_diag));\n\tif (CHECK_FLAG(bs->flags, BFD_SESS_FLAG_CONFIG))\n\t\tjson_object_string_add(jo, "type", "configured");\n\telse\n\t\tjson_object_string_add(jo, "type", "dynamic");\n\n\tjson_object_int_add(jo, "receive-interval",\n\t\t\t    bs->timers.required_min_rx / 1000);\n\tjson_object_int_add(jo, "transmit-interval",\n\t\t\t    bs->timers.desired_min_tx / 1000);\n\tif (bs->xmt_TO_actual > 0)\n\t\tjson_object_int_add(jo, "transmit-interval-actual",\n\t\t\t\t    bs->xmt_TO_actual / 1000);\n\tif (bs->detect_TO > 0)\n\t\tjson_object_int_add(jo, "detection-timeout",\n\t\t\t\t    bs->detect_TO / 1000);\n\tjson_object_int_add(jo, "echo-receive-interval",\n\t\t\t    bs->timers.required_min_echo_rx / 1000);\n\tif (bs->bfd_mode == BFD_MODE_TYPE_SBFD_INIT || bs->bfd_mode == BFD_MODE_TYPE_SBFD_ECHO) {\n\t\tjson_object_int_add(jo, "configured-echo-transmit-interval",\n\t\t\t\t    bs->timers.desired_min_echo_tx / 1000);\n\t\tjson_object_int_add(jo, "current-echo-transmit-interval", bs->echo_xmt_TO / 1000);\n\t\tjson_object_int_add(jo, "current-detect-echo-receive-interval",\n\t\t\t\t    bs->echo_detect_TO / 1000);\n\t} else if (CHECK_FLAG(bs->flags, BFD_SESS_FLAG_ECHO))\n\t\tjson_object_int_add(jo, "echo-transmit-interval",\n\t\t\t\t    bs->timers.desired_min_echo_tx / 1000);\n\telse\n\t\tjson_object_int_add(jo, "echo-transmit-interval", 0);\n\n\tjson_object_int_add(jo, "detect-multiplier", bs->detect_mult);\n\n\tjson_object_int_add(jo, "remote-receive-interval",\n\t\t\t    bs->remote_timers.required_min_rx / 1000);\n\tjson_object_int_add(jo, "remote-transmit-interval",\n\t\t\t    bs->remote_timers.desired_min_tx / 1000);\n\tjson_object_int_add(jo, "remote-echo-receive-interval",\n\t\t\t    bs->remote_timers.required_min_echo / 1000);\n\tjson_object_int_add(jo, "remote-detect-multiplier",\n\t\t\t    bs->remote_detect_mult);\n\n\t_display_rtt(&min, &avg, &max, bs);\n\tjson_object_int_add(jo, "rtt-min", min);\n\tjson_object_int_add(jo, "rtt-avg", avg);\n\tjson_object_int_add(jo, "rtt-max", max);\n\n\treturn jo;\n}\n\nstatic void _display_peer_json(struct vty *vty, struct bfd_session *bs)\n{\n\tstruct json_object *jo = __display_peer_json(bs);\n\n\tvty_json(vty, jo);\n}\n\nstruct bfd_vrf_tuple {\n\tconst char *vrfname;\n\tstruct vty *vty;\n\tstruct json_object *jo;\n\tconst char *bfdname;\n};\n\nstatic void _display_peer_iter(struct hash_bucket *hb, void *arg)\n{\n\tstruct bfd_vrf_tuple *bvt = (struct bfd_vrf_tuple *)arg;\n\tstruct vty *vty;\n\tstruct bfd_session *bs = hb->data;\n\n\tif (!bvt)\n\t\treturn;\n\tvty = bvt->vty;\n\n\tif (bvt->vrfname) {\n\t\tif (!bs->key.vrfname[0] ||\n\t\t    !strmatch(bs->key.vrfname, bvt->vrfname))\n\t\t\treturn;\n\t}\n\t_display_peer(vty, bs);\n}\n\nstatic void _display_bfd_by_bfdname_iter(struct hash_bucket *hb, void *arg)\n{\n\tstruct bfd_vrf_tuple *bvt = (struct bfd_vrf_tuple *)arg;\n\tstruct vty *vty;\n\tstruct bfd_session *bs = hb->data;\n\n\tif (!bvt)\n\t\treturn;\n\tvty = bvt->vty;\n\n\tif (bvt->vrfname) {\n\t\tif (!bs->key.vrfname[0] || !strmatch(bs->key.vrfname, bvt->vrfname))\n\t\t\treturn;\n\t}\n\n\tif (bvt->bfdname) {\n\t\tif ((!bs->key.bfdname[0] || !strmatch(bs->key.bfdname, bvt->bfdname)) &&\n\t\t    (!bs->bfd_name[0] || !strmatch(bs->bfd_name, bvt->bfdname)))\n\t\t\treturn;\n\t}\n\n\t_display_peer(vty, bs);\n}\n\nstatic void _display_peer_json_iter(struct hash_bucket *hb, void *arg)\n{\n\tstruct bfd_vrf_tuple *bvt = (struct bfd_vrf_tuple *)arg;\n\tstruct json_object *jo, *jon = NULL;\n\tstruct bfd_session *bs = hb->data;\n\n\tif (!bvt)\n\t\treturn;\n\tjo = bvt->jo;\n\n\tif (bvt->vrfname) {\n\t\tif (!bs->key.vrfname[0] ||\n\t\t    !strmatch(bs->key.vrfname, bvt->vrfname))\n\t\t\treturn;\n\t}\n\n\tjon = __display_peer_json(bs);\n\tif (jon == NULL) {\n\t\tzlog_warn("%s: not enough memory", __func__);\n\t\treturn;\n\t}\n\n\tjson_object_array_add(jo, jon);\n}\n\nstatic void _display_bfd_by_bfdname_json_iter(struct hash_bucket *hb, void *arg)\n{\n\tstruct bfd_vrf_tuple *bvt = (struct bfd_vrf_tuple *)arg;\n\tstruct json_object *jo, *jon = NULL;\n\tstruct bfd_session *bs = hb->data;\n\n\tif (!bvt)\n\t\treturn;\n\tjo = bvt->jo;\n\n\tif (bvt->vrfname) {\n\t\tif (!bs->key.vrfname[0] || !strmatch(bs->key.vrfname, bvt->vrfname))\n\t\t\treturn;\n\t}\n\n\tif (bvt->bfdname) {\n\t\tif ((!bs->key.bfdname[0] || !strmatch(bs->key.bfdname, bvt->bfdname)) &&\n\t\t    (!bs->bfd_name[0] || !strmatch(bs->bfd_name, bvt->bfdname)))\n\t\t\treturn;\n\t}\n\n\tjon = __display_peer_json(bs);\n\tif (jon == NULL) {\n\t\tzlog_warn("%s: not enough memory", __func__);\n\t\treturn;\n\t}\n\n\tjson_object_array_add(jo, jon);\n}\nstatic void _display_bfd_by_bfdname(struct vty *vty, const char *vrfname, const char *bfdname,\n\t\t\t\t    bool use_json)\n{\n\tstruct json_object *jo;\n\tstruct bfd_vrf_tuple bvt = { 0 };\n\n\tbvt.vrfname = vrfname;\n\tbvt.bfdname = bfdname;\n\n\tif (!use_json) {\n\t\tbvt.vty = vty;\n\t\tvty_out(vty, "BFD Peers:\\n");\n\t\tbfd_id_iterate(_display_bfd_by_bfdname_iter, &bvt);\n\t\treturn;\n\t}\n\n\tjo = json_object_new_array();\n\tbvt.jo = jo;\n\tbfd_id_iterate(_display_bfd_by_bfdname_json_iter, &bvt);\n\n\tvty_json(vty, jo);\n}\n\nstatic void _display_all_peers(struct vty *vty, char *vrfname, bool use_json)\n{\n\tstruct json_object *jo;\n\tstruct bfd_vrf_tuple bvt = {0};\n\n\tbvt.vrfname = vrfname;\n\n\tif (!use_json) {\n\t\tbvt.vty = vty;\n\t\tvty_out(vty, "BFD Peers:\\n");\n\t\tbfd_id_iterate(_display_peer_iter, &bvt);\n\t\treturn;\n\t}\n\n\tjo = json_object_new_array();\n\tbvt.jo = jo;\n\tbfd_id_iterate(_display_peer_json_iter, &bvt);\n\n\tvty_json(vty, jo);\n}\n\nstatic void _display_peer_counter(struct vty *vty, struct bfd_session *bs)\n{\n\t_display_peer_header(vty, bs);\n\n\t/* Ask data plane for updated counters. */\n\tif (bfd_dplane_update_session_counters(bs) == -1) {\n\t\tzlog_debug("%s: failed to update BFD session counters (%s)",\n\t\t\t   __func__, bs_to_string(bs));\n\t\tfrrtrace(3, frr_bfd, stats_error, 1, bs->discrs.my_discr, -1);\n\t}\n\n\tvty_out(vty, "\\t\\tID: %u\\n", bs->discrs.my_discr);\n\tvty_out(vty, "\\t\\tControl packet input: %" PRIu64 " packets\\n",\n\t\tbs->stats.rx_ctrl_pkt);\n\tvty_out(vty, "\\t\\tControl packet output: %" PRIu64 " packets\\n",\n\t\tbs->stats.tx_ctrl_pkt);\n\tvty_out(vty, "\\t\\tEcho packet input: %" PRIu64 " packets\\n",\n\t\tbs->stats.rx_echo_pkt);\n\tvty_out(vty, "\\t\\tEcho packet output: %" PRIu64 " packets\\n",\n\t\tbs->stats.tx_echo_pkt);\n\tvty_out(vty, "\\t\\tSession up events: %" PRIu64 "\\n",\n\t\tbs->stats.session_up);\n\tvty_out(vty, "\\t\\tSession down events: %" PRIu64 "\\n",\n\t\tbs->stats.session_down);\n\tvty_out(vty, "\\t\\tZebra notifications: %" PRIu64 "\\n",\n\t\tbs->stats.znotification);\n\tvty_out(vty, "\\t\\tTx fail packet: %" PRIu64 "\\n", bs->stats.tx_fail_pkt);\n\tvty_out(vty, "\\n");\n}\n\nstatic struct json_object *__display_peer_counters_json(struct bfd_session *bs)\n{\n\tstruct json_object *jo = _peer_json_header(bs);\n\n\t/* Ask data plane for updated counters. */\n\tif (bfd_dplane_update_session_counters(bs) == -1) {\n\t\tzlog_debug("%s: failed to update BFD session counters (%s)",\n\t\t\t   __func__, bs_to_string(bs));\n\t\tfrrtrace(3, frr_bfd, stats_error, 1, bs->discrs.my_discr, -1);\n\t}\n\n\tjson_object_int_add(jo, "id", bs->discrs.my_discr);\n\tjson_object_int_add(jo, "control-packet-input", bs->stats.rx_ctrl_pkt);\n\tjson_object_int_add(jo, "control-packet-output", bs->stats.tx_ctrl_pkt);\n\tjson_object_int_add(jo, "echo-packet-input", bs->stats.rx_echo_pkt);\n\tjson_object_int_add(jo, "echo-packet-output", bs->stats.tx_echo_pkt);\n\tjson_object_int_add(jo, "session-up", bs->stats.session_up);\n\tjson_object_int_add(jo, "session-down", bs->stats.session_down);\n\tjson_object_int_add(jo, "zebra-notifications", bs->stats.znotification);\n\n\tif (bs->bfd_mode == BFD_MODE_TYPE_SBFD_INIT || bs->bfd_mode == BFD_MODE_TYPE_SBFD_ECHO)\n\t\tjson_object_int_add(jo, "tx-fail-packet", bs->stats.tx_fail_pkt);\n\n\treturn jo;\n}\n\nstatic void _display_peer_counters_json(struct vty *vty, struct bfd_session *bs)\n{\n\tstruct json_object *jo = __display_peer_counters_json(bs);\n\n\tvty_json(vty, jo);\n}\n\nstatic void _display_peer_counter_iter(struct hash_bucket *hb, void *arg)\n{\n\tstruct bfd_vrf_tuple *bvt = arg;\n\tstruct vty *vty;\n\tstruct bfd_session *bs = hb->data;\n\n\tif (!bvt)\n\t\treturn;\n\tvty = bvt->vty;\n\n\tif (bvt->vrfname) {\n\t\tif (!bs->key.vrfname[0] ||\n\t\t    !strmatch(bs->key.vrfname, bvt->vrfname))\n\t\t\treturn;\n\t}\n\n\t_display_peer_counter(vty, bs);\n}\n\nstatic void _display_peer_counter_json_iter(struct hash_bucket *hb, void *arg)\n{\n\tstruct json_object *jo, *jon = NULL;\n\tstruct bfd_session *bs = hb->data;\n\tstruct bfd_vrf_tuple *bvt = arg;\n\n\tif (!bvt)\n\t\treturn;\n\tjo  = bvt->jo;\n\n\tif (bvt->vrfname) {\n\t\tif (!bs->key.vrfname[0] ||\n\t\t    !strmatch(bs->key.vrfname, bvt->vrfname))\n\t\t\treturn;\n\t}\n\n\tjon = __display_peer_counters_json(bs);\n\tif (jon == NULL) {\n\t\tzlog_warn("%s: not enough memory", __func__);\n\t\treturn;\n\t}\n\n\tjson_object_array_add(jo, jon);\n}\n\nstatic void _display_peers_counter(struct vty *vty, char *vrfname, bool use_json)\n{\n\tstruct json_object *jo;\n\tstruct bfd_vrf_tuple bvt = {0};\n\n\tbvt.vrfname = vrfname;\n\tif (!use_json) {\n\t\tbvt.vty = vty;\n\t\tvty_out(vty, "BFD Peers:\\n");\n\t\tbfd_id_iterate(_display_peer_counter_iter, &bvt);\n\t\treturn;\n\t}\n\n\tjo = json_object_new_array();\n\tbvt.jo = jo;\n\tbfd_id_iterate(_display_peer_counter_json_iter, &bvt);\n\n\tvty_json(vty, jo);\n}\n\nstatic void _display_bfd_counters_by_bfdname_iter(struct hash_bucket *hb, void *arg)\n{\n\tstruct bfd_vrf_tuple *bvt = arg;\n\tstruct vty *vty;\n\tstruct bfd_session *bs = hb->data;\n\n\tif (!bvt)\n\t\treturn;\n\tvty = bvt->vty;\n\n\tif (bvt->vrfname) {\n\t\tif (!bs->key.vrfname[0] || !strmatch(bs->key.vrfname, bvt->vrfname))\n\t\t\treturn;\n\t}\n\n\tif (bvt->bfdname) {\n\t\tif (!bs->key.bfdname[0] || !strmatch(bs->key.bfdname, bvt->bfdname))\n\t\t\treturn;\n\t}\n\n\t_display_peer_counter(vty, bs);\n}\nstatic void _display_bfd_counters_json_by_bfdname_iter(struct hash_bucket *hb, void *arg)\n{\n\tstruct json_object *jo, *jon = NULL;\n\tstruct bfd_session *bs = hb->data;\n\tstruct bfd_vrf_tuple *bvt = arg;\n\n\tif (!bvt)\n\t\treturn;\n\tjo = bvt->jo;\n\n\tif (bvt->vrfname) {\n\t\tif (!bs->key.vrfname[0] || !strmatch(bs->key.vrfname, bvt->vrfname))\n\t\t\treturn;\n\t}\n\n\tif (bvt->bfdname) {\n\t\tif (!bs->key.bfdname[0] || !strmatch(bs->key.bfdname, bvt->bfdname))\n\t\t\treturn;\n\t}\n\n\tjon = __display_peer_counters_json(bs);\n\tif (jon == NULL) {\n\t\tzlog_warn("%s: not enough memory", __func__);\n\t\treturn;\n\t}\n\n\tjson_object_array_add(jo, jon);\n}\nstatic void _display_bfd_counters_by_bfdname(struct vty *vty, const char *vrfname,\n\t\t\t\t\t     const char *bfdname, bool use_json)\n{\n\tstruct json_object *jo;\n\tstruct bfd_vrf_tuple bvt = { 0 };\n\n\tbvt.vrfname = vrfname;\n\tbvt.bfdname = bfdname;\n\n\tif (!use_json) {\n\t\tbvt.vty = vty;\n\t\tvty_out(vty, "BFD Peers:\\n");\n\t\tbfd_id_iterate(_display_bfd_counters_by_bfdname_iter, &bvt);\n\t\treturn;\n\t}\n\n\tjo = json_object_new_array();\n\tbvt.jo = jo;\n\tbfd_id_iterate(_display_bfd_counters_json_by_bfdname_iter, &bvt);\n\n\tvty_json(vty, jo);\n}\nstatic void _clear_bfd_counters_by_bfdname_iter(struct hash_bucket *hb, void *arg)\n{\n\tstruct bfd_vrf_tuple *bvt = arg;\n\tstruct bfd_session *bs = hb->data;\n\n\tif (!bvt)\n\t\treturn;\n\n\tif (bvt->vrfname) {\n\t\tif (!bs->key.vrfname[0] || !strmatch(bs->key.vrfname, bvt->vrfname))\n\t\t\treturn;\n\t}\n\n\tif (bvt->bfdname) {\n\t\tif (!bs->key.bfdname[0] || !strmatch(bs->key.bfdname, bvt->bfdname))\n\t\t\treturn;\n\t}\n\n\t_clear_peer_counter(bs);\n}\n\nstatic void _clear_bfd_counters_by_bfdname(const char *vrfname, const char *bfdname)\n{\n\tstruct bfd_vrf_tuple bvt = { 0 };\n\n\tbvt.vrfname = vrfname;\n\tbvt.bfdname = bfdname;\n\n\tbfd_id_iterate(_clear_bfd_counters_by_bfdname_iter, &bvt);\n}\n\nstatic void _clear_peer_counter(struct bfd_session *bs)\n{\n\t/* Clear only pkt stats, intention is not to loose system\n\t   events counters */\n\tbs->stats.rx_ctrl_pkt = 0;\n\tbs->stats.tx_ctrl_pkt = 0;\n\tbs->stats.rx_echo_pkt = 0;\n\tbs->stats.tx_echo_pkt = 0;\n}\n\nstatic void _display_peer_brief(struct vty *vty, struct bfd_session *bs)\n{\n\tchar addr_buf[INET6_ADDRSTRLEN];\n\n\tif (CHECK_FLAG(bs->flags, BFD_SESS_FLAG_MH)) {\n\t\tvty_out(vty, "%-10u", bs->discrs.my_discr);\n\t\tinet_ntop(bs->key.family, &bs->key.local, addr_buf, sizeof(addr_buf));\n\t\tvty_out(vty, " %-40s", addr_buf);\n\t\tinet_ntop(bs->key.family, &bs->key.peer, addr_buf, sizeof(addr_buf));\n\t\tvty_out(vty, " %-40s", addr_buf);\n\t\tvty_out(vty, "%-15s\\n", state_list[bs->ses_state].str);\n\t} else {\n\t\tvty_out(vty, "%-10u", bs->discrs.my_discr);\n\t\tvty_out(vty, " %-40s", satostr(&bs->local_address));\n\t\tinet_ntop(bs->key.family, &bs->key.peer, addr_buf, sizeof(addr_buf));\n\t\tvty_out(vty, " %-40s", addr_buf);\n\n\t\tvty_out(vty, "%-15s\\n", state_list[bs->ses_state].str);\n\t}\n}\n\nstatic void _display_peer_brief_iter(struct hash_bucket *hb, void *arg)\n{\n\tstruct bfd_vrf_tuple *bvt = arg;\n\tstruct vty *vty;\n\tstruct bfd_session *bs = hb->data;\n\n\tif (!bvt)\n\t\treturn;\n\tvty = bvt->vty;\n\n\tif (bvt->vrfname) {\n\t\tif (!bs->key.vrfname[0] ||\n\t\t\t!strmatch(bs->key.vrfname, bvt->vrfname))\n\t\treturn;\n\t}\n\n\t_display_peer_brief(vty, bs);\n}\n\nstatic void _display_peers_brief(struct vty *vty, const char *vrfname, bool use_json)\n{\n\tstruct json_object *jo;\n\tstruct bfd_vrf_tuple bvt = {0};\n\n\tbvt.vrfname = vrfname;\n\n\tif (!use_json) {\n\t\tbvt.vty = vty;\n\n\t\tvty_out(vty, "Session count: %lu\\n", bfd_get_session_count());\n\t\tvty_out(vty, "%-10s", "SessionId");\n\t\tvty_out(vty, " %-40s", "LocalAddress");\n\t\tvty_out(vty, " %-40s", "PeerAddress");\n\t\tvty_out(vty, "%-15s\\n", "Status");\n\n\t\tvty_out(vty, "%-10s", "=========");\n\t\tvty_out(vty, " %-40s", "============");\n\t\tvty_out(vty, " %-40s", "===========");\n\t\tvty_out(vty, "%-15s\\n", "======");\n\n\t\tbfd_id_iterate(_display_peer_brief_iter, &bvt);\n\t\treturn;\n\t}\n\n\tjo = json_object_new_array();\n\tbvt.jo = jo;\n\n\tbfd_id_iterate(_display_peer_json_iter, &bvt);\n\n\tvty_json(vty, jo);\n}\n\nstatic struct bfd_session *\n_find_peer_or_error(struct vty *vty, int argc, struct cmd_token **argv,\n\t\t    const char *label, const char *peer_str,\n\t\t    const char *local_str, const char *ifname,\n\t\t    const char *vrfname)\n{\n\tint idx;\n\tbool mhop;\n\tstruct bfd_session *bs = NULL;\n\tstruct bfd_peer_cfg bpc;\n\tstruct sockaddr_any psa, lsa, *lsap;\n\tchar errormsg[128];\n\tstruct vrf *vrf = NULL;\n\tchar *tmpName = NULL;\n\n\tif (peer_str) {\n\t\tstrtosa(peer_str, &psa);\n\t\tif (local_str) {\n\t\t\tstrtosa(local_str, &lsa);\n\t\t\tlsap = &lsa;\n\t\t} else\n\t\t\tlsap = NULL;\n\n\t\tidx = 0;\n\t\tmhop = argv_find(argv, argc, "multihop", &idx);\n\n\t\ttmpName = (char *)vrfname;\n\t\tif (vrfname) {\n\t\t\tvrf = vrf_lookup_by_name(vrfname);\n\t\t\tif (vrf == NULL) {\n\t\t\t\tvty_out(vty, "%% Vrf is not exist: %s\\n", vrfname);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\ttmpName = vrf->name;\n\t\t}\n\n\t\tif (bfd_configure_peer(&bpc, mhop, &psa, lsap, ifname, tmpName, errormsg,\n\t\t\t\t       sizeof(errormsg)) != 0) {\n\t\t\tvty_out(vty, "%% Invalid peer configuration: %s\\n",\n\t\t\t\terrormsg);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tbs = bs_peer_find(&bpc);\n\t} else {\n\t\tvty_out(vty, "%% Invalid arguments\\n");\n\t\treturn NULL;\n\t}\n\n\t/* Find peer data. */\n\tif (bs == NULL) {\n\t\tvty_out(vty, "%% Unable to find \'peer %s",\n\t\t\tlabel ? label : peer_str);\n\t\tif (ifname)\n\t\t\tvty_out(vty, " interface %s", ifname);\n\t\tif (local_str)\n\t\t\tvty_out(vty, " local-address %s", local_str);\n\t\tif (vrfname)\n\t\t\tvty_out(vty, " vrf %s", vrfname);\n\t\tvty_out(vty, "\'\\n");\n\n\t\treturn NULL;\n\t}\n\n\treturn bs;\n}\n\nvoid _display_rtt(uint32_t *min, uint32_t *avg, uint32_t *max,\n\t\t  struct bfd_session *bs)\n{\n#ifdef BFD_LINUX\n\tuint8_t i;\n\tuint32_t average = 0;\n\n\tif (bs->rtt_valid == 0)\n\t\treturn;\n\n\t*max = bs->rtt[0];\n\t*min = 1000;\n\t*avg = 0;\n\n\tfor (i = 0; i < bs->rtt_valid; i++) {\n\t\tif (bs->rtt[i] < *min)\n\t\t\t*min = bs->rtt[i];\n\t\tif (bs->rtt[i] > *max)\n\t\t\t*max = bs->rtt[i];\n\t\taverage += bs->rtt[i];\n\t}\n\t*avg = average / bs->rtt_valid;\n\n#endif\n}\n\n/*\n * Show commands.\n */\nDEFPY(bfd_show_by_bfdname, bfd_show_by_bfdname_cmd,\n      "show bfd [vrf NAME$vrf_name] bfd-name BFDNAME$bfdname [json]",\n      SHOW_STR\n      "Bidirection Forwarding Detection\\n"\n      VRF_CMD_HELP_STR\n\t  "Specify bfd session name\\n"\n\t  "bfd session name\\n"\n\t  JSON_STR)\n{\n\t_display_bfd_by_bfdname(vty, vrf_name, bfdname, use_json(argc, argv));\n\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(bfd_show_counters_by_bfdname, bfd_show_counters_by_bfdname_cmd,\n      "show bfd [vrf NAME$vrf_name] bfd-name BFDNAME$bfdname counters [json]",\n      SHOW_STR\n      "Bidirection Forwarding Detection\\n"\n      VRF_CMD_HELP_STR\n\t  "Specify bfd session name\\n"\n\t  "bfd session name\\n"\n      "Show BFD peer counters information\\n"\n      JSON_STR)\n{\n\t_display_bfd_counters_by_bfdname(vty, vrf_name, bfdname, use_json(argc, argv));\n\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(bfd_clear_counters_by_bfdname, bfd_clear_counters_by_bfdname_cmd,\n      "clear bfd [vrf NAME$vrfname] bfd-name BFDNAME$bfdname counters",\n      CLEAR_STR\n      "Bidirection Forwarding Detection\\n"\n      VRF_CMD_HELP_STR\n\t  "Specify bfd session name\\n"\n\t  "bfd session name\\n"\n\t  "clear BFD peer counters information\\n")\n{\n\t_clear_bfd_counters_by_bfdname(vrfname, bfdname);\n\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(bfd_show_peers, bfd_show_peers_cmd, "show bfd [vrf NAME] peers [json]",\n      SHOW_STR\n      "Bidirection Forwarding Detection\\n"\n       VRF_CMD_HELP_STR\n      "BFD peers status\\n" JSON_STR)\n{\n\tchar *vrf_name = NULL;\n\tint idx_vrf = 0;\n\n\tif (argv_find(argv, argc, "vrf", &idx_vrf))\n\t\tvrf_name = argv[idx_vrf + 1]->arg;\n\n\t_display_all_peers(vty, vrf_name, use_json(argc, argv));\n\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(bfd_show_peer, bfd_show_peer_cmd,\n      "show bfd [vrf NAME$vrf_name] peer <WORD$label|<A.B.C.D|X:X::X:X>$peer [{multihop|local-address <A.B.C.D|X:X::X:X>$local|interface IFNAME$ifname}]> [json]",\n      SHOW_STR\n      "Bidirection Forwarding Detection\\n"\n      VRF_CMD_HELP_STR\n      "BFD peers status\\n"\n      "Peer label\\n" PEER_IPV4_STR PEER_IPV6_STR MHOP_STR LOCAL_STR\n\t      LOCAL_IPV4_STR LOCAL_IPV6_STR INTERFACE_STR LOCAL_INTF_STR JSON_STR)\n{\n\tstruct bfd_session *bs;\n\n\t/* Look up the BFD peer. */\n\tbs = _find_peer_or_error(vty, argc, argv, label, peer_str, local_str,\n\t\t\t\t ifname, vrf_name);\n\tif (bs == NULL)\n\t\treturn CMD_WARNING_CONFIG_FAILED;\n\n\tif (use_json(argc, argv)) {\n\t\t_display_peer_json(vty, bs);\n\t} else {\n\t\tvty_out(vty, "BFD Peer:\\n");\n\t\t_display_peer(vty, bs);\n\t}\n\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(bfd_show_peer_counters, bfd_show_peer_counters_cmd,\n      "show bfd [vrf NAME$vrf_name] peer <WORD$label|<A.B.C.D|X:X::X:X>$peer [{multihop|local-address <A.B.C.D|X:X::X:X>$local|interface IFNAME$ifname}]> counters [json]",\n      SHOW_STR\n      "Bidirection Forwarding Detection\\n"\n      VRF_CMD_HELP_STR\n      "BFD peers status\\n"\n      "Peer label\\n"\n      PEER_IPV4_STR\n      PEER_IPV6_STR\n      MHOP_STR\n      LOCAL_STR\n      LOCAL_IPV4_STR\n      LOCAL_IPV6_STR\n      INTERFACE_STR\n      LOCAL_INTF_STR\n      "Show BFD peer counters information\\n"\n      JSON_STR)\n{\n\tstruct bfd_session *bs;\n\n\t/* Look up the BFD peer. */\n\tbs = _find_peer_or_error(vty, argc, argv, label, peer_str, local_str,\n\t\t\t\t ifname, vrf_name);\n\tif (bs == NULL)\n\t\treturn CMD_WARNING_CONFIG_FAILED;\n\n\tif (use_json(argc, argv))\n\t\t_display_peer_counters_json(vty, bs);\n\telse\n\t\t_display_peer_counter(vty, bs);\n\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(bfd_show_peers_counters, bfd_show_peers_counters_cmd,\n      "show bfd [vrf NAME] peers counters [json]",\n      SHOW_STR\n      "Bidirection Forwarding Detection\\n"\n      VRF_CMD_HELP_STR\n      "BFD peers status\\n"\n      "Show BFD peer counters information\\n"\n      JSON_STR)\n{\n\tchar *vrf_name = NULL;\n\tint idx_vrf = 0;\n\n\tif (argv_find(argv, argc, "vrf", &idx_vrf))\n\t\tvrf_name = argv[idx_vrf + 1]->arg;\n\n\t_display_peers_counter(vty, vrf_name, use_json(argc, argv));\n\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(bfd_clear_peer_counters, bfd_clear_peer_counters_cmd,\n      "clear bfd [vrf <NAME$vrfname>] peer <WORD$label|<A.B.C.D|X:X::X:X>$peer [{multihop|local-address <A.B.C.D|X:X::X:X>$local|interface IFNAME$ifname}]> counters",\n      SHOW_STR\n      "Bidirection Forwarding Detection\\n"\n      VRF_CMD_HELP_STR\n      "BFD peers status\\n"\n      "Peer label\\n"\n      PEER_IPV4_STR\n      PEER_IPV6_STR\n      MHOP_STR\n      LOCAL_STR\n      LOCAL_IPV4_STR\n      LOCAL_IPV6_STR\n      INTERFACE_STR\n      LOCAL_INTF_STR\n      "clear BFD peer counters information\\n")\n{\n\tstruct bfd_session *bs;\n\n\t/* Look up the BFD peer. */\n\tbs = _find_peer_or_error(vty, argc, argv, label, peer_str, local_str,\n\t\t\t\tifname, vrfname);\n\tif (bs == NULL)\n\t\treturn CMD_WARNING_CONFIG_FAILED;\n\n\t_clear_peer_counter(bs);\n\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(bfd_show_peers_brief, bfd_show_peers_brief_cmd,\n      "show bfd [vrf <NAME$vrfname>] peers brief [json]",\n      SHOW_STR\n      "Bidirection Forwarding Detection\\n"\n      VRF_CMD_HELP_STR\n      "BFD peers status\\n"\n      "Show BFD peer information in tabular form\\n"\n      JSON_STR)\n{\n\tchar *vrf_name = NULL;\n\tint idx_vrf = 0;\n\n\tif (argv_find(argv, argc, "vrf", &idx_vrf))\n\t\tvrf_name = argv[idx_vrf + 1]->arg;\n\n\t_display_peers_brief(vty, vrf_name, use_json(argc, argv));\n\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(show_bfd_distributed, show_bfd_distributed_cmd,\n      "show bfd distributed",\n      SHOW_STR\n      "Bidirection Forwarding Detection\\n"\n      "Show BFD data plane (distributed BFD) statistics\\n")\n{\n\tbfd_dplane_show_counters(vty);\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(\n\tbfd_debug_distributed, bfd_debug_distributed_cmd,\n\t"[no] debug bfd distributed",\n\tNO_STR\n\tDEBUG_STR\n\t"Bidirection Forwarding Detection\\n"\n\t"BFD data plane (distributed BFD) debugging\\n")\n{\n\tbglobal.debug_dplane = !no;\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(\n\tbfd_debug_peer, bfd_debug_peer_cmd,\n\t"[no] debug bfd peer",\n\tNO_STR\n\tDEBUG_STR\n\t"Bidirection Forwarding Detection\\n"\n\t"Peer events debugging\\n")\n{\n\tbglobal.debug_peer_event = !no;\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(\n\tbfd_debug_zebra, bfd_debug_zebra_cmd,\n\t"[no] debug bfd zebra",\n\tNO_STR\n\tDEBUG_STR\n\t"Bidirection Forwarding Detection\\n"\n\t"Zebra events debugging\\n")\n{\n\tbglobal.debug_zebra = !no;\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(\n\tbfd_debug_network, bfd_debug_network_cmd,\n\t"[no] debug bfd network",\n\tNO_STR\n\tDEBUG_STR\n\t"Bidirection Forwarding Detection\\n"\n\t"Network layer debugging\\n")\n{\n\tbglobal.debug_network = !no;\n\treturn CMD_SUCCESS;\n}\n\n/*\n * Function definitions.\n */\n\n/*\n * Configuration rules:\n *\n * Single hop:\n * peer + (interface name)\n *\n * Multi hop:\n * peer + local + (optional vrf)\n *\n * Anything else is misconfiguration.\n */\nstatic int bfd_configure_peer(struct bfd_peer_cfg *bpc, bool mhop,\n\t\t\t      const struct sockaddr_any *peer,\n\t\t\t      const struct sockaddr_any *local,\n\t\t\t      const char *ifname, const char *vrfname,\n\t\t\t      char *ebuf, size_t ebuflen)\n{\n\tmemset(bpc, 0, sizeof(*bpc));\n\n\t/* Defaults */\n\tbpc->bpc_shutdown = false;\n\tbpc->bpc_log_session_changes = false;\n\tbpc->bpc_detectmultiplier = BPC_DEF_DETECTMULTIPLIER;\n\tbpc->bpc_recvinterval = BPC_DEF_RECEIVEINTERVAL;\n\tbpc->bpc_txinterval = BPC_DEF_TRANSMITINTERVAL;\n\tbpc->bpc_echorecvinterval = BPC_DEF_ECHORECEIVEINTERVAL;\n\tbpc->bpc_echotxinterval = BPC_DEF_ECHOTRANSMITINTERVAL;\n\n\t/* Safety check: when no error buf is provided len must be zero. */\n\tif (ebuf == NULL)\n\t\tebuflen = 0;\n\n\t/* Peer is always mandatory. */\n\tif (peer == NULL) {\n\t\tsnprintf(ebuf, ebuflen, "peer must not be empty");\n\t\treturn -1;\n\t}\n\n\t/* Validate address families. */\n\tif (peer->sa_sin.sin_family == AF_INET) {\n\t\tif (local && local->sa_sin.sin_family != AF_INET) {\n\t\t\tsnprintf(ebuf, ebuflen,\n\t\t\t\t "local is IPv6, but peer is IPv4");\n\t\t\treturn -1;\n\t\t}\n\n\t\tbpc->bpc_ipv4 = true;\n\t} else if (peer->sa_sin.sin_family == AF_INET6) {\n\t\tif (local && local->sa_sin.sin_family != AF_INET6) {\n\t\t\tsnprintf(ebuf, ebuflen,\n\t\t\t\t "local is IPv4, but peer is IPv6");\n\t\t\treturn -1;\n\t\t}\n\n\t\tbpc->bpc_ipv4 = false;\n\t} else {\n\t\tsnprintf(ebuf, ebuflen, "invalid peer address family");\n\t\treturn -1;\n\t}\n\n\t/* Copy local and/or peer addresses. */\n\tif (local)\n\t\tbpc->bpc_local = *local;\n\n\tbpc->bpc_peer = *peer;\n\tbpc->bpc_mhop = mhop;\n\n\t/* Handle interface specification configuration. */\n\tif (ifname) {\n\t\tbpc->bpc_has_localif = true;\n\t\tif (strlcpy(bpc->bpc_localif, ifname, sizeof(bpc->bpc_localif))\n\t\t    > sizeof(bpc->bpc_localif)) {\n\t\t\tsnprintf(ebuf, ebuflen, "interface name too long");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Handle VRF configuration. */\n\tif (vrfname) {\n\t\tbpc->bpc_has_vrfname = true;\n\t\tif (strlcpy(bpc->bpc_vrfname, vrfname, sizeof(bpc->bpc_vrfname))\n\t\t    > sizeof(bpc->bpc_vrfname)) {\n\t\t\tsnprintf(ebuf, ebuflen, "vrf name too long");\n\t\t\treturn -1;\n\t\t}\n\t} else {\n\t\tbpc->bpc_has_vrfname = true;\n\t\tstrlcpy(bpc->bpc_vrfname, VRF_DEFAULT_NAME, sizeof(bpc->bpc_vrfname));\n\t}\n\n\treturn 0;\n}\n\nDEFUN_NOSH(show_debugging_bfd,\n\t   show_debugging_bfd_cmd,\n\t   "show debugging [bfd]",\n\t   SHOW_STR\n\t   DEBUG_STR\n\t   "BFD daemon\\n")\n{\n\tvty_out(vty, "BFD debugging status:\\n");\n\tif (bglobal.debug_dplane)\n\t\tvty_out(vty, "  Distributed BFD debugging is on.\\n");\n\tif (bglobal.debug_peer_event)\n\t\tvty_out(vty, "  Peer events debugging is on.\\n");\n\tif (bglobal.debug_zebra)\n\t\tvty_out(vty, "  Zebra events debugging is on.\\n");\n\tif (bglobal.debug_network)\n\t\tvty_out(vty, "  Network layer debugging is on.\\n");\n\n\tcmd_show_lib_debugs(vty);\n\n\treturn CMD_SUCCESS;\n}\n\nstatic int bfdd_write_config(struct vty *vty);\nstruct cmd_node bfd_node = {\n\t.name = "bfd",\n\t.node = BFD_NODE,\n\t.parent_node = CONFIG_NODE,\n\t.prompt = "%s(config-bfd)# ",\n\t.config_write = bfdd_write_config,\n};\n\nstruct cmd_node bfd_peer_node = {\n\t.name = "bfd peer",\n\t.node = BFD_PEER_NODE,\n\t.parent_node = BFD_NODE,\n\t.prompt = "%s(config-bfd-peer)# ",\n};\n\nstatic void _sbfd_reflector_write_config(struct hash_bucket *hb, void *arg)\n{\n\tstruct sbfd_reflector *sr = hb->data;\n\tchar buf[INET6_ADDRSTRLEN];\n\tstruct vty *vty;\n\n\tvty = (struct vty *)arg;\n\tinet_ntop(AF_INET6, &sr->local, buf, sizeof(buf));\n\tvty_out(vty, "  sbfd reflector source-address %s discriminator %u\\n", buf, sr->discr);\n}\n\nstatic void sbfd_reflector_write_config(struct vty *vty)\n{\n\tsbfd_discr_iterate(_sbfd_reflector_write_config, vty);\n}\n\nstatic int bfdd_write_config(struct vty *vty)\n{\n\tstruct lyd_node *dnode;\n\tint written = 0;\n\n\tif (bglobal.debug_dplane) {\n\t\tvty_out(vty, "debug bfd distributed\\n");\n\t\twritten = 1;\n\t}\n\n\tif (bglobal.debug_peer_event) {\n\t\tvty_out(vty, "debug bfd peer\\n");\n\t\twritten = 1;\n\t}\n\n\tif (bglobal.debug_zebra) {\n\t\tvty_out(vty, "debug bfd zebra\\n");\n\t\twritten = 1;\n\t}\n\n\tif (bglobal.debug_network) {\n\t\tvty_out(vty, "debug bfd network\\n");\n\t\twritten = 1;\n\t}\n\n\tdnode = yang_dnode_get(running_config->dnode, "/frr-bfdd:bfdd");\n\tif (dnode) {\n\t\tnb_cli_show_dnode_cmds(vty, dnode, false);\n\t\twritten = 1;\n\t}\n\n\t/*sbfd config*/\n\tsbfd_reflector_write_config(vty);\n\n\treturn written;\n}\n\n/*\n * Micro-BFD LAG show commands (RFC 7130)\n */\n#include "bfd_lag.h"\n\nDEFPY(show_bfd_lag, show_bfd_lag_cmd,\n      "show bfd lag [LAGNAME$lagname] [json]",\n      SHOW_STR\n      "Bidirection Forwarding Detection\\n"\n      "Show Micro-BFD LAG sessions\\n"\n      "Specific LAG name\\n"\n      JSON_STR)\n{\n\tstruct json_object *json_out = NULL;\n\n\tif (use_json(argc, argv))\n\t\tjson_out = json_object_new_object();\n\n\tbfd_lag_show(vty, lagname, json_out);\n\n\tif (json_out) {\n\t\tvty_json(vty, json_out);\n\t}\n\n\treturn CMD_SUCCESS;\n}\n\nDEFPY(show_bfd_lag_members, show_bfd_lag_members_cmd,\n      "show bfd lag LAGNAME$lagname members [json]",\n      SHOW_STR\n      "Bidirection Forwarding Detection\\n"\n      "Show Micro-BFD LAG sessions\\n"\n      "LAG name\\n"\n      "Show member links status\\n"\n      JSON_STR)\n{\n\tstruct bfd_lag *lag;\n\tstruct json_object *json_out = NULL;\n\n\tlag = bfd_lag_find(lagname, NULL);\n\tif (lag == NULL) {\n\t\tvty_out(vty, "%% Cannot find LAG %s\\n", lagname);\n\t\treturn CMD_WARNING;\n\t}\n\n\tif (use_json(argc, argv))\n\t\tjson_out = json_object_new_object();\n\n\tbfd_lag_show_members(vty, lag, json_out);\n\n\tif (json_out) {\n\t\tvty_json(vty, json_out);\n\t}\n\n\treturn CMD_SUCCESS;\n}\n\nvoid bfdd_vty_init(void)\n{\n\tinstall_element(ENABLE_NODE, &bfd_show_peers_counters_cmd);\n\tinstall_element(ENABLE_NODE, &bfd_show_peer_counters_cmd);\n\tinstall_element(ENABLE_NODE, &bfd_clear_peer_counters_cmd);\n\tinstall_element(ENABLE_NODE, &bfd_show_peers_cmd);\n\tinstall_element(ENABLE_NODE, &bfd_show_by_bfdname_cmd);\n\tinstall_element(ENABLE_NODE, &bfd_show_counters_by_bfdname_cmd);\n\tinstall_element(ENABLE_NODE, &bfd_clear_counters_by_bfdname_cmd);\n\tinstall_element(ENABLE_NODE, &bfd_show_peer_cmd);\n\tinstall_element(ENABLE_NODE, &bfd_show_peers_brief_cmd);\n\tinstall_element(ENABLE_NODE, &show_bfd_distributed_cmd);\n\tinstall_element(ENABLE_NODE, &show_debugging_bfd_cmd);\n\n\t/* Micro-BFD LAG show commands (RFC 7130) */\n\tinstall_element(ENABLE_NODE, &show_bfd_lag_cmd);\n\tinstall_element(ENABLE_NODE, &show_bfd_lag_members_cmd);\n\tinstall_element(VIEW_NODE, &show_bfd_lag_cmd);\n\tinstall_element(VIEW_NODE, &show_bfd_lag_members_cmd);\n\n\tinstall_element(ENABLE_NODE, &bfd_debug_distributed_cmd);\n\tinstall_element(ENABLE_NODE, &bfd_debug_peer_cmd);\n\tinstall_element(ENABLE_NODE, &bfd_debug_zebra_cmd);\n\tinstall_element(ENABLE_NODE, &bfd_debug_network_cmd);\n\n\tinstall_element(CONFIG_NODE, &bfd_debug_distributed_cmd);\n\tinstall_element(CONFIG_NODE, &bfd_debug_peer_cmd);\n\tinstall_element(CONFIG_NODE, &bfd_debug_zebra_cmd);\n\tinstall_element(CONFIG_NODE, &bfd_debug_network_cmd);\n\n\t/* Install BFD node and commands. */\n\tinstall_node(&bfd_node);\n\tinstall_default(BFD_NODE);\n\n\t/* Install BFD peer node. */\n\tinstall_node(&bfd_peer_node);\n\tinstall_default(BFD_PEER_NODE);\n\n\tbfdd_cli_init();\n}\n' : show bfd lag members command should be defined

======================================================================
STATUS: 3 TEST(S) FAILED
======================================================================